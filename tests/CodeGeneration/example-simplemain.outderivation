stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function 
rule: 
<START>: [EPSILON: epsilon] <multiClassDeclOrFuncDef> [CREATE_NODE: program] 
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <classDeclOrFuncDef> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function 
rule: 
<multiClassDeclOrFuncDef>: <classDeclOrFuncDef> <multiClassDeclOrFuncDef> 
semantic stack: 
[epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <funcDef> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function 
rule: 
<classDeclOrFuncDef>: <funcDef> 
semantic stack: 
[epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHead> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function 
rule: 
<funcDef>: <funcHead> <funcBody> [CREATE_NODE: function] 
semantic stack: 
[epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] id function [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function 
rule: 
<funcHead>: [EPSILON: epsilon] function id [CREATE_LEAF: id] <funcHeadFollowing> 
semantic stack: 
[epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] id 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function 
rule: 
matching: function [function, function, 48]
semantic stack: 
[epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main 
rule: 
matching: id [id, main, 48]
semantic stack: 
[epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( 
rule: 
<funcHeadFollowing>: openpar [EPSILON: epsilon] <fParams> [CREATE_NODE: fParams] closepar returntype <returnType> [CREATE_NODE: normalFunctionHead] 
semantic stack: 
[epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( 
rule: 
matching: openpar [openpar, (, 48]
semantic stack: 
[epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) 
rule: 
<fParams>: 
semantic stack: 
[epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) 
rule: 
matching: closepar [closepar, ), 48]
semantic stack: 
[epsilon][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
rule: 
matching: returntype [returntype, =>, 48]
semantic stack: 
[epsilon][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] [CREATE_NODE: returnType] void 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void 
rule: 
<returnType>: void [CREATE_NODE: returnType] 
semantic stack: 
[epsilon][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] [CREATE_NODE: returnType] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void 
rule: 
matching: void [void, void, 49]
semantic stack: 
[epsilon][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> opencubr [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
rule: 
<funcBody>: [EPSILON: epsilon] opencubr <multiLocalVarDeclOrStmt> closecubr [CREATE_NODE: functionBody] 
semantic stack: 
[epsilon][normalFunctionHead]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
rule: 
matching: opencubr [opencubr, {, 49]
semantic stack: 
[epsilon][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDecl> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar 
rule: 
<localVarDeclOrStmt>: <localVarDecl> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id localvar [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar 
rule: 
<localVarDecl>: [EPSILON: epsilon] localvar id [CREATE_LEAF: id] colon <type> <localVarDeclFollowing> [CREATE_NODE: localVarDecl] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar 
rule: 
matching: localvar [localvar, localvar, 50]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x 
rule: 
matching: id [id, x, 50]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : 
rule: 
matching: colon [colon, :, 50]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: integer] integer 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer 
rule: 
<type>: integer [CREATE_LEAF: integer] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: integer] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer 
rule: 
matching: integer [integer, integer, 50]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; 
rule: 
<localVarDeclFollowing>: [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] semi 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][id][integer]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][id][integer][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; 
rule: 
matching: semi [semi, ;, 50]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][id][integer][arraySizes]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
rule: 
skipping
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDecl> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar 
rule: 
<localVarDeclOrStmt>: <localVarDecl> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id localvar [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar 
rule: 
<localVarDecl>: [EPSILON: epsilon] localvar id [CREATE_LEAF: id] colon <type> <localVarDeclFollowing> [CREATE_NODE: localVarDecl] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar 
rule: 
matching: localvar [localvar, localvar, 51]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y 
rule: 
matching: id [id, y, 51]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : 
rule: 
matching: colon [colon, :, 51]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: integer] integer 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer 
rule: 
<type>: integer [CREATE_LEAF: integer] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: integer] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer 
rule: 
matching: integer [integer, integer, 51]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; 
rule: 
<localVarDeclFollowing>: [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] semi 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][epsilon][id][integer]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][epsilon][id][integer][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; 
rule: 
matching: semi [semi, ;, 51]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][epsilon][id][integer][arraySizes]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
rule: 
skipping
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDecl> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar 
rule: 
<localVarDeclOrStmt>: <localVarDecl> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id localvar [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar 
rule: 
<localVarDecl>: [EPSILON: epsilon] localvar id [CREATE_LEAF: id] colon <type> <localVarDeclFollowing> [CREATE_NODE: localVarDecl] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar 
rule: 
matching: localvar [localvar, localvar, 52]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z 
rule: 
matching: id [id, z, 52]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : 
rule: 
matching: colon [colon, :, 52]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: integer] integer 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer 
rule: 
<type>: integer [CREATE_LEAF: integer] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: integer] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer 
rule: 
matching: integer [integer, integer, 52]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; 
rule: 
<localVarDeclFollowing>: [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] semi 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][id][integer]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][id][integer][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; 
rule: 
matching: semi [semi, ;, 52]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][id][integer][arraySizes]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
rule: 
skipping
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y 
rule: 
matching: id [id, y, 53]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 
rule: 
matching: assign [assign, =, 53]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 
rule: 
matching: intnum [intnum, 1, 53]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> <addOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 
rule: 
<rightrecArithExpr>: <addOp> <term> <rightrecArithExpr> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] plus 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 
rule: 
<addOp>: plus [CREATE_LEAF: plus] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 
rule: 
matching: plus [plus, +, 53]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][epsilon][term][plus]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 
rule: 
matching: intnum [intnum, 2, 53]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> <multOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 
rule: 
<rightrecTerm>: <multOp> <factor> <rightrecTerm> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [CREATE_LEAF: mult] mult 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 
rule: 
<multOp>: mult [CREATE_LEAF: mult] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [CREATE_LEAF: mult] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 
rule: 
matching: mult [mult, *, 53]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon][numFactor][mult]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 
rule: 
matching: intnum [intnum, 3, 53]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon][numFactor][mult]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon][numFactor][mult][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][epsilon][term][plus][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; 
rule: 
matching: semi [semi, ;, 53]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
rule: 
skipping
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi closepar [CREATE_NODE: readStatement] <variable> [EPSILON: epsilon] openpar read 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read 
rule: 
<statement>: read openpar [EPSILON: epsilon] <variable> [CREATE_NODE: readStatement] closepar semi 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi closepar [CREATE_NODE: readStatement] <variable> [EPSILON: epsilon] openpar 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read 
rule: 
matching: read [read, read, 54]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi closepar [CREATE_NODE: readStatement] <variable> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( 
rule: 
matching: openpar [openpar, (, 54]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi closepar [CREATE_NODE: readStatement] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x 
rule: 
<variable>: [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi closepar [CREATE_NODE: readStatement] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x 
rule: 
matching: id [id, x, 54]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi closepar [CREATE_NODE: readStatement] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi closepar [CREATE_NODE: readStatement] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) 
rule: 
matching: closepar [closepar, ), 54]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; 
rule: 
matching: semi [semi, ;, 54]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
rule: 
skipping
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <relExpr> [EPSILON: epsilon] openpar if 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if 
rule: 
<statement>: if openpar [EPSILON: epsilon] <relExpr> [CREATE_NODE: ifCondition] closepar then [EPSILON: epsilon] <statBlock> [CREATE_NODE: thenStatements] else [EPSILON: epsilon] <statBlock> [CREATE_NODE: elseStatements] [CREATE_NODE: ifStatement] semi 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <relExpr> [EPSILON: epsilon] openpar 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if 
rule: 
matching: if [if, if, 55]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <relExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( 
rule: 
matching: openpar [openpar, (, 55]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> <arithExpr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x 
rule: 
<relExpr>: <arithExpr> <relOp> <arithExpr> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x 
rule: 
matching: id [id, x, 55]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> [CREATE_LEAF: gt] gt 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > 
rule: 
<relOp>: gt [CREATE_LEAF: gt] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> [CREATE_LEAF: gt] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > 
rule: 
matching: gt [gt, >, 55]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][epsilon][arithExpr][gt]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][epsilon][arithExpr][gt][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][epsilon][arithExpr][gt][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y 
rule: 
matching: id [id, y, 55]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][epsilon][arithExpr][gt][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][epsilon][arithExpr][gt][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][epsilon][arithExpr][gt][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][epsilon][arithExpr][gt][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> <addOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 
rule: 
<rightrecArithExpr>: <addOp> <term> <rightrecArithExpr> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][epsilon][arithExpr][gt][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] plus 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 
rule: 
<addOp>: plus [CREATE_LEAF: plus] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][epsilon][arithExpr][gt][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 
rule: 
matching: plus [plus, +, 55]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][epsilon][arithExpr][gt][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][epsilon][arithExpr][gt][epsilon][term][plus]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][epsilon][arithExpr][gt][epsilon][term][plus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 
rule: 
matching: intnum [intnum, 10, 55]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][epsilon][arithExpr][gt][epsilon][term][plus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][epsilon][arithExpr][gt][epsilon][term][plus][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][epsilon][arithExpr][gt][epsilon][term][plus][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) 
rule: 
matching: closepar [closepar, ), 55]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then 
rule: 
matching: then [then, then, 55]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> opencubr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { 
rule: 
<statBlock>: opencubr <multiStatement> closecubr 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { 
rule: 
matching: opencubr [opencubr, {, 55]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
rule: 
skipping
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write 
rule: 
<multiStatement>: <statement> <multiStatement> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar <expr> openpar write 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write 
rule: 
<statement>: write openpar <expr> closepar [CREATE_NODE: writeStatement] semi 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar <expr> openpar 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write 
rule: 
matching: write [write, write, 56]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( 
rule: 
matching: openpar [openpar, (, 56]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x 
rule: 
matching: id [id, x, 56]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][epsilon][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][epsilon][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> <addOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 
rule: 
<rightrecArithExpr>: <addOp> <term> <rightrecArithExpr> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][epsilon][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] plus 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 
rule: 
<addOp>: plus [CREATE_LEAF: plus] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][epsilon][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 
rule: 
matching: plus [plus, +, 56]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][epsilon][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][epsilon][epsilon][epsilon][term][plus]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][epsilon][epsilon][epsilon][term][plus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 
rule: 
matching: intnum [intnum, 10, 56]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][epsilon][epsilon][epsilon][term][plus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][epsilon][epsilon][epsilon][term][plus][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][epsilon][epsilon][epsilon][term][plus][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][epsilon][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) 
rule: 
matching: closepar [closepar, ), 56]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][epsilon][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; 
rule: 
matching: semi [semi, ;, 56]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][epsilon][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
rule: 
skipping
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][epsilon][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} 
rule: 
<multiStatement>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][epsilon][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} 
rule: 
matching: closecubr [closecubr, }, 57]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][epsilon][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else 
rule: 
matching: else [else, else, 57]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][thenStatements]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> opencubr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
rule: 
<statBlock>: opencubr <multiStatement> closecubr 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][thenStatements][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
rule: 
matching: opencubr [opencubr, {, 57]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][thenStatements][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write 
rule: 
<multiStatement>: <statement> <multiStatement> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][thenStatements][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar <expr> openpar write 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write 
rule: 
<statement>: write openpar <expr> closepar [CREATE_NODE: writeStatement] semi 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][thenStatements][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar <expr> openpar 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write 
rule: 
matching: write [write, write, 58]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][thenStatements][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( 
rule: 
matching: openpar [openpar, (, 58]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][thenStatements][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][thenStatements][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][thenStatements][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][thenStatements][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][thenStatements][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x 
rule: 
matching: id [id, x, 58]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][thenStatements][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][thenStatements][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][thenStatements][epsilon][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][thenStatements][epsilon][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> <addOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 
rule: 
<rightrecArithExpr>: <addOp> <term> <rightrecArithExpr> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][thenStatements][epsilon][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] plus 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 
rule: 
<addOp>: plus [CREATE_LEAF: plus] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][thenStatements][epsilon][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 
rule: 
matching: plus [plus, +, 58]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][thenStatements][epsilon][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][thenStatements][epsilon][epsilon][epsilon][term][plus]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][thenStatements][epsilon][epsilon][epsilon][term][plus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 
rule: 
matching: intnum [intnum, 1, 58]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][thenStatements][epsilon][epsilon][epsilon][term][plus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][thenStatements][epsilon][epsilon][epsilon][term][plus][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][thenStatements][epsilon][epsilon][epsilon][term][plus][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][thenStatements][epsilon][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) 
rule: 
matching: closepar [closepar, ), 58]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][thenStatements][epsilon][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; 
rule: 
matching: semi [semi, ;, 58]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][thenStatements][epsilon][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
rule: 
skipping
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][thenStatements][epsilon][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} 
rule: 
<multiStatement>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][thenStatements][epsilon][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} 
rule: 
matching: closecubr [closecubr, }, 59]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifCondition][thenStatements][epsilon][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
rule: 
matching: semi [semi, ;, 59]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z 
rule: 
matching: id [id, z, 60]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 
rule: 
matching: assign [assign, =, 60]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][epsilon][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 
rule: 
matching: intnum [intnum, 0, 60]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][epsilon][idIndice][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][epsilon][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; 
rule: 
matching: semi [semi, ;, 60]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
rule: 
skipping
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <relExpr> [EPSILON: epsilon] openpar while 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while 
rule: 
<statement>: while openpar [EPSILON: epsilon] <relExpr> [CREATE_NODE: whileCondition] closepar [EPSILON: epsilon] <statBlock> [CREATE_NODE: whileBlockStatements] [CREATE_NODE: whileStatement] semi 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <relExpr> [EPSILON: epsilon] openpar 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while 
rule: 
matching: while [while, while, 61]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <relExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( 
rule: 
matching: openpar [openpar, (, 61]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> <arithExpr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z 
rule: 
<relExpr>: <arithExpr> <relOp> <arithExpr> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z 
rule: 
matching: id [id, z, 61]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> [CREATE_LEAF: leq] leq 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 
rule: 
<relOp>: leq [CREATE_LEAF: leq] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> [CREATE_LEAF: leq] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 
rule: 
matching: leq [leq, <=, 61]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][epsilon][arithExpr][leq]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][epsilon][arithExpr][leq][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][epsilon][arithExpr][leq][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 
rule: 
matching: intnum [intnum, 10, 61]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][epsilon][arithExpr][leq][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][epsilon][arithExpr][leq][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][epsilon][arithExpr][leq][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) 
rule: 
matching: closepar [closepar, ), 61]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> opencubr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { 
rule: 
<statBlock>: opencubr <multiStatement> closecubr 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { 
rule: 
matching: opencubr [opencubr, {, 61]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
rule: 
skipping
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write 
rule: 
<multiStatement>: <statement> <multiStatement> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar <expr> openpar write 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write 
rule: 
<statement>: write openpar <expr> closepar [CREATE_NODE: writeStatement] semi 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar <expr> openpar 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write 
rule: 
matching: write [write, write, 62]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write ( 
rule: 
matching: openpar [openpar, (, 62]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write ( z 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write ( z 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write ( z 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write ( z 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write ( z 
rule: 
matching: id [id, z, 62]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write ( z ) 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write ( z ) 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write ( z ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write ( z ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write ( z ) 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write ( z ) 
rule: 
matching: closepar [closepar, ), 62]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write ( z ) ; 
rule: 
matching: semi [semi, ;, 62]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write ( z ) ; // 3.4 
rule: 
skipping
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write ( z ) ; // 3.4 
z 
rule: 
<multiStatement>: <statement> <multiStatement> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write ( z ) ; // 3.4 
z 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write ( z ) ; // 3.4 
z 
rule: 
matching: id [id, z, 63]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write ( z ) ; // 3.4 
z = 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write ( z ) ; // 3.4 
z = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write ( z ) ; // 3.4 
z = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write ( z ) ; // 3.4 
z = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write ( z ) ; // 3.4 
z = 
rule: 
matching: assign [assign, =, 63]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write ( z ) ; // 3.4 
z = z 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write ( z ) ; // 3.4 
z = z 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write ( z ) ; // 3.4 
z = z 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write ( z ) ; // 3.4 
z = z 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write ( z ) ; // 3.4 
z = z 
rule: 
matching: id [id, z, 63]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write ( z ) ; // 3.4 
z = z + 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write ( z ) ; // 3.4 
z = z + 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write ( z ) ; // 3.4 
z = z + 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> <addOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write ( z ) ; // 3.4 
z = z + 
rule: 
<rightrecArithExpr>: <addOp> <term> <rightrecArithExpr> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] plus 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write ( z ) ; // 3.4 
z = z + 
rule: 
<addOp>: plus [CREATE_LEAF: plus] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write ( z ) ; // 3.4 
z = z + 
rule: 
matching: plus [plus, +, 63]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write ( z ) ; // 3.4 
z = z + 1 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice][epsilon][epsilon][term][plus]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write ( z ) ; // 3.4 
z = z + 1 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write ( z ) ; // 3.4 
z = z + 1 
rule: 
matching: intnum [intnum, 1, 63]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write ( z ) ; // 3.4 
z = z + 1 ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write ( z ) ; // 3.4 
z = z + 1 ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice][epsilon][epsilon][term][plus][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write ( z ) ; // 3.4 
z = z + 1 ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write ( z ) ; // 3.4 
z = z + 1 ; 
rule: 
matching: semi [semi, ;, 63]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write ( z ) ; // 3.4 
z = z + 1 ; // 3.1 
rule: 
skipping
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write ( z ) ; // 3.4 
z = z + 1 ; // 3.1 
} 
rule: 
<multiStatement>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write ( z ) ; // 3.4 
z = z + 1 ; // 3.1 
} 
rule: 
matching: closecubr [closecubr, }, 64]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write ( z ) ; // 3.4 
z = z + 1 ; // 3.1 
} ; 
rule: 
matching: semi [semi, ;, 64]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write ( z ) ; // 3.4 
z = z + 1 ; // 3.1 
} ; 
} 
rule: 
<multiLocalVarDeclOrStmt>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write ( z ) ; // 3.4 
z = z + 1 ; // 3.1 
} ; 
} 
rule: 
matching: closecubr [closecubr, }, 65]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][assignStatement][readStatement][ifStatement][assignStatement][whileStatement]
-----------------------------------------------------------------------
stack: 
<$> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |     |  X  | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |     |  X  | 
// 2.2: |     |  X  | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |     |  X  | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  |  
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |     |  X  | 
// 5.3: |     |  X  | 
//      ------------- 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
read ( x ) ; // 3.4 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
while ( z <= 10 ) { // 3.3, 5.1 
write ( z ) ; // 3.4 
z = z + 1 ; // 3.1 
} ; 
} 
rule: 
<multiClassDeclOrFuncDef>: 
semantic stack: 
[program]
-----------------------------------------------------------------------
