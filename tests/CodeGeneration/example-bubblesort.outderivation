stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function 
rule: 
<START>: [EPSILON: epsilon] <multiClassDeclOrFuncDef> [CREATE_NODE: program] 
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <classDeclOrFuncDef> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function 
rule: 
<multiClassDeclOrFuncDef>: <classDeclOrFuncDef> <multiClassDeclOrFuncDef> 
semantic stack: 
[epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <funcDef> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function 
rule: 
<classDeclOrFuncDef>: <funcDef> 
semantic stack: 
[epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHead> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function 
rule: 
<funcDef>: <funcHead> <funcBody> [CREATE_NODE: function] 
semantic stack: 
[epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] id function [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function 
rule: 
<funcHead>: [EPSILON: epsilon] function id [CREATE_LEAF: id] <funcHeadFollowing> 
semantic stack: 
[epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] id 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function 
rule: 
matching: function [function, function, 49]
semantic stack: 
[epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort 
rule: 
matching: id [id, bubbleSort, 49]
semantic stack: 
[epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( 
rule: 
<funcHeadFollowing>: openpar [EPSILON: epsilon] <fParams> [CREATE_NODE: fParams] closepar returntype <returnType> [CREATE_NODE: normalFunctionHead] 
semantic stack: 
[epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( 
rule: 
matching: openpar [openpar, (, 49]
semantic stack: 
[epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr 
rule: 
<fParams>: [EPSILON: epsilon] id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: fParam] <multiFParamsTail> 
semantic stack: 
[epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr 
rule: 
matching: id [id, arr, 49]
semantic stack: 
[epsilon][epsilon][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : 
rule: 
matching: colon [colon, :, 49]
semantic stack: 
[epsilon][epsilon][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: integer] integer 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer 
rule: 
<type>: integer [CREATE_LEAF: integer] 
semantic stack: 
[epsilon][epsilon][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: integer] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer 
rule: 
matching: integer [integer, integer, 49]
semantic stack: 
[epsilon][epsilon][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> <arraySize> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 
rule: 
<multiArraySize>: <arraySize> <multiArraySize> 
semantic stack: 
[epsilon][epsilon][id][epsilon][epsilon][id][integer][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> <arraySizeParam> [EPSILON: epsilon] opensqbr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 
rule: 
<arraySize>: opensqbr [EPSILON: epsilon] <arraySizeParam> 
semantic stack: 
[epsilon][epsilon][id][epsilon][epsilon][id][integer][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> <arraySizeParam> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 
rule: 
matching: opensqbr [opensqbr, [, 49]
semantic stack: 
[epsilon][epsilon][id][epsilon][epsilon][id][integer][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [CREATE_NODE: arraySize] closesqbr [CREATE_LEAF: intNum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 
rule: 
<arraySizeParam>: intnum [CREATE_LEAF: intNum] closesqbr [CREATE_NODE: arraySize] 
semantic stack: 
[epsilon][epsilon][id][epsilon][epsilon][id][integer][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [CREATE_NODE: arraySize] closesqbr [CREATE_LEAF: intNum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 
rule: 
matching: intnum [intnum, 7, 49]
semantic stack: 
[epsilon][epsilon][id][epsilon][epsilon][id][integer][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [CREATE_NODE: arraySize] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] 
rule: 
matching: closesqbr [closesqbr, ], 49]
semantic stack: 
[epsilon][epsilon][id][epsilon][epsilon][id][integer][epsilon][epsilon][intNum]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][epsilon][id][epsilon][epsilon][id][integer][epsilon][arraySize]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> <fParamsTail> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , 
rule: 
<multiFParamsTail>: <fParamsTail> <multiFParamsTail> 
semantic stack: 
[epsilon][epsilon][id][epsilon][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id comma [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , 
rule: 
<fParamsTail>: [EPSILON: epsilon] comma id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: fParam] 
semantic stack: 
[epsilon][epsilon][id][epsilon][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , 
rule: 
matching: comma [comma, ,, 49]
semantic stack: 
[epsilon][epsilon][id][epsilon][fParam][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size 
rule: 
matching: id [id, size, 49]
semantic stack: 
[epsilon][epsilon][id][epsilon][fParam][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : 
rule: 
matching: colon [colon, :, 49]
semantic stack: 
[epsilon][epsilon][id][epsilon][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: integer] integer 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer 
rule: 
<type>: integer [CREATE_LEAF: integer] 
semantic stack: 
[epsilon][epsilon][id][epsilon][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: integer] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer 
rule: 
matching: integer [integer, integer, 49]
semantic stack: 
[epsilon][epsilon][id][epsilon][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][epsilon][id][epsilon][fParam][epsilon][id][integer][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) 
rule: 
<multiFParamsTail>: 
semantic stack: 
[epsilon][epsilon][id][epsilon][fParam][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) 
rule: 
matching: closepar [closepar, ), 49]
semantic stack: 
[epsilon][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => 
rule: 
matching: returntype [returntype, =>, 49]
semantic stack: 
[epsilon][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] [CREATE_NODE: returnType] void 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void 
rule: 
<returnType>: void [CREATE_NODE: returnType] 
semantic stack: 
[epsilon][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] [CREATE_NODE: returnType] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void 
rule: 
matching: void [void, void, 49]
semantic stack: 
[epsilon][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
rule: 
skipping
semantic stack: 
[epsilon][normalFunctionHead]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> opencubr [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
rule: 
<funcBody>: [EPSILON: epsilon] opencubr <multiLocalVarDeclOrStmt> closecubr [CREATE_NODE: functionBody] 
semantic stack: 
[epsilon][normalFunctionHead]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
rule: 
matching: opencubr [opencubr, {, 50]
semantic stack: 
[epsilon][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDecl> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar 
rule: 
<localVarDeclOrStmt>: <localVarDecl> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id localvar [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar 
rule: 
<localVarDecl>: [EPSILON: epsilon] localvar id [CREATE_LEAF: id] colon <type> <localVarDeclFollowing> [CREATE_NODE: localVarDecl] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar 
rule: 
matching: localvar [localvar, localvar, 51]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n 
rule: 
matching: id [id, n, 51]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : 
rule: 
matching: colon [colon, :, 51]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: integer] integer 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer 
rule: 
<type>: integer [CREATE_LEAF: integer] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: integer] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer 
rule: 
matching: integer [integer, integer, 51]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; 
rule: 
<localVarDeclFollowing>: [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] semi 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][id][integer]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][id][integer][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; 
rule: 
matching: semi [semi, ;, 51]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][id][integer][arraySizes]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
rule: 
skipping
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDecl> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar 
rule: 
<localVarDeclOrStmt>: <localVarDecl> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id localvar [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar 
rule: 
<localVarDecl>: [EPSILON: epsilon] localvar id [CREATE_LEAF: id] colon <type> <localVarDeclFollowing> [CREATE_NODE: localVarDecl] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar 
rule: 
matching: localvar [localvar, localvar, 52]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i 
rule: 
matching: id [id, i, 52]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : 
rule: 
matching: colon [colon, :, 52]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: integer] integer 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer 
rule: 
<type>: integer [CREATE_LEAF: integer] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: integer] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer 
rule: 
matching: integer [integer, integer, 52]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; 
rule: 
<localVarDeclFollowing>: [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] semi 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][epsilon][id][integer]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][epsilon][id][integer][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; 
rule: 
matching: semi [semi, ;, 52]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][epsilon][id][integer][arraySizes]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
rule: 
skipping
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDecl> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar 
rule: 
<localVarDeclOrStmt>: <localVarDecl> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id localvar [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar 
rule: 
<localVarDecl>: [EPSILON: epsilon] localvar id [CREATE_LEAF: id] colon <type> <localVarDeclFollowing> [CREATE_NODE: localVarDecl] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar 
rule: 
matching: localvar [localvar, localvar, 53]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j 
rule: 
matching: id [id, j, 53]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : 
rule: 
matching: colon [colon, :, 53]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: integer] integer 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer 
rule: 
<type>: integer [CREATE_LEAF: integer] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: integer] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer 
rule: 
matching: integer [integer, integer, 53]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; 
rule: 
<localVarDeclFollowing>: [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] semi 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][id][integer]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][id][integer][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; 
rule: 
matching: semi [semi, ;, 53]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][id][integer][arraySizes]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
rule: 
skipping
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDecl> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar 
rule: 
<localVarDeclOrStmt>: <localVarDecl> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id localvar [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar 
rule: 
<localVarDecl>: [EPSILON: epsilon] localvar id [CREATE_LEAF: id] colon <type> <localVarDeclFollowing> [CREATE_NODE: localVarDecl] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar 
rule: 
matching: localvar [localvar, localvar, 54]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp 
rule: 
matching: id [id, temp, 54]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : 
rule: 
matching: colon [colon, :, 54]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: integer] integer 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer 
rule: 
<type>: integer [CREATE_LEAF: integer] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: integer] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer 
rule: 
matching: integer [integer, integer, 54]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; 
rule: 
<localVarDeclFollowing>: [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] semi 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][id][integer]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][id][integer][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; 
rule: 
matching: semi [semi, ;, 54]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][id][integer][arraySizes]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
rule: 
skipping
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n 
rule: 
matching: id [id, n, 55]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = 
rule: 
matching: assign [assign, =, 55]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size 
rule: 
matching: id [id, size, 55]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; 
rule: 
matching: semi [semi, ;, 55]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
rule: 
skipping
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i 
rule: 
matching: id [id, i, 56]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 
rule: 
matching: assign [assign, =, 56]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 
rule: 
matching: intnum [intnum, 0, 56]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; 
rule: 
matching: semi [semi, ;, 56]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
rule: 
skipping
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j 
rule: 
matching: id [id, j, 57]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 
rule: 
matching: assign [assign, =, 57]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 
rule: 
matching: intnum [intnum, 0, 57]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; 
rule: 
matching: semi [semi, ;, 57]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
rule: 
skipping
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp 
rule: 
matching: id [id, temp, 58]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 
rule: 
matching: assign [assign, =, 58]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 
rule: 
matching: intnum [intnum, 0, 58]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; 
rule: 
matching: semi [semi, ;, 58]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
rule: 
skipping
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <relExpr> [EPSILON: epsilon] openpar while 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while 
rule: 
<statement>: while openpar [EPSILON: epsilon] <relExpr> [CREATE_NODE: whileCondition] closepar [EPSILON: epsilon] <statBlock> [CREATE_NODE: whileBlockStatements] [CREATE_NODE: whileStatement] semi 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <relExpr> [EPSILON: epsilon] openpar 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while 
rule: 
matching: while [while, while, 59]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <relExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( 
rule: 
matching: openpar [openpar, (, 59]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> <arithExpr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i 
rule: 
<relExpr>: <arithExpr> <relOp> <arithExpr> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i 
rule: 
matching: id [id, i, 59]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> [CREATE_LEAF: lt] lt 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < 
rule: 
<relOp>: lt [CREATE_LEAF: lt] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> [CREATE_LEAF: lt] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < 
rule: 
matching: lt [lt, <, 59]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][arithExpr][lt]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][arithExpr][lt][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][arithExpr][lt][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n 
rule: 
matching: id [id, n, 59]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][arithExpr][lt][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][arithExpr][lt][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][arithExpr][lt][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][arithExpr][lt][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> <addOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 
rule: 
<rightrecArithExpr>: <addOp> <term> <rightrecArithExpr> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][arithExpr][lt][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: minus] minus 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 
rule: 
<addOp>: minus [CREATE_LEAF: minus] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][arithExpr][lt][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: minus] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 
rule: 
matching: minus [minus, -, 59]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][arithExpr][lt][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][arithExpr][lt][epsilon][term][minus]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][arithExpr][lt][epsilon][term][minus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 
rule: 
matching: intnum [intnum, 1, 59]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][arithExpr][lt][epsilon][term][minus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][arithExpr][lt][epsilon][term][minus][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][arithExpr][lt][epsilon][term][minus][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) 
rule: 
matching: closepar [closepar, ), 59]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> opencubr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { 
rule: 
<statBlock>: opencubr <multiStatement> closecubr 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { 
rule: 
matching: opencubr [opencubr, {, 59]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
rule: 
skipping
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j 
rule: 
<multiStatement>: <statement> <multiStatement> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j 
rule: 
matching: id [id, j, 60]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 
rule: 
matching: assign [assign, =, 60]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][epsilon][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 
rule: 
matching: intnum [intnum, 0, 60]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][epsilon][idIndice][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][epsilon][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; 
rule: 
matching: semi [semi, ;, 60]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
rule: 
skipping
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while 
rule: 
<multiStatement>: <statement> <multiStatement> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <relExpr> [EPSILON: epsilon] openpar while 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while 
rule: 
<statement>: while openpar [EPSILON: epsilon] <relExpr> [CREATE_NODE: whileCondition] closepar [EPSILON: epsilon] <statBlock> [CREATE_NODE: whileBlockStatements] [CREATE_NODE: whileStatement] semi 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <relExpr> [EPSILON: epsilon] openpar 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while 
rule: 
matching: while [while, while, 61]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <relExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( 
rule: 
matching: openpar [openpar, (, 61]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> <arithExpr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j 
rule: 
<relExpr>: <arithExpr> <relOp> <arithExpr> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j 
rule: 
matching: id [id, j, 61]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> [CREATE_LEAF: lt] lt 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < 
rule: 
<relOp>: lt [CREATE_LEAF: lt] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> [CREATE_LEAF: lt] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < 
rule: 
matching: lt [lt, <, 61]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][epsilon][arithExpr][lt]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][epsilon][arithExpr][lt][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][epsilon][arithExpr][lt][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n 
rule: 
matching: id [id, n, 61]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][epsilon][arithExpr][lt][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][epsilon][arithExpr][lt][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][epsilon][arithExpr][lt][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][epsilon][arithExpr][lt][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> <addOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - 
rule: 
<rightrecArithExpr>: <addOp> <term> <rightrecArithExpr> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][epsilon][arithExpr][lt][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: minus] minus 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - 
rule: 
<addOp>: minus [CREATE_LEAF: minus] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][epsilon][arithExpr][lt][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: minus] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - 
rule: 
matching: minus [minus, -, 61]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][epsilon][arithExpr][lt][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][epsilon][arithExpr][lt][epsilon][term][minus]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][epsilon][arithExpr][lt][epsilon][term][minus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i 
rule: 
matching: id [id, i, 61]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][epsilon][arithExpr][lt][epsilon][term][minus][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][epsilon][arithExpr][lt][epsilon][term][minus][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][epsilon][arithExpr][lt][epsilon][term][minus][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][epsilon][arithExpr][lt][epsilon][term][minus][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> <addOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 
rule: 
<rightrecArithExpr>: <addOp> <term> <rightrecArithExpr> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][epsilon][arithExpr][lt][epsilon][term][minus][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: minus] minus 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 
rule: 
<addOp>: minus [CREATE_LEAF: minus] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][epsilon][arithExpr][lt][epsilon][term][minus][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: minus] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 
rule: 
matching: minus [minus, -, 61]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][epsilon][arithExpr][lt][epsilon][term][minus][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][epsilon][arithExpr][lt][epsilon][term][minus][term][minus]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][epsilon][arithExpr][lt][epsilon][term][minus][term][minus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 
rule: 
matching: intnum [intnum, 1, 61]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][epsilon][arithExpr][lt][epsilon][term][minus][term][minus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][epsilon][arithExpr][lt][epsilon][term][minus][term][minus][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][epsilon][arithExpr][lt][epsilon][term][minus][term][minus][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) 
rule: 
matching: closepar [closepar, ), 61]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> opencubr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { 
rule: 
<statBlock>: opencubr <multiStatement> closecubr 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { 
rule: 
matching: opencubr [opencubr, {, 61]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
rule: 
skipping
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if 
rule: 
<multiStatement>: <statement> <multiStatement> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <relExpr> [EPSILON: epsilon] openpar if 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if 
rule: 
<statement>: if openpar [EPSILON: epsilon] <relExpr> [CREATE_NODE: ifCondition] closepar then [EPSILON: epsilon] <statBlock> [CREATE_NODE: thenStatements] else [EPSILON: epsilon] <statBlock> [CREATE_NODE: elseStatements] [CREATE_NODE: ifStatement] semi 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <relExpr> [EPSILON: epsilon] openpar 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if 
rule: 
matching: if [if, if, 62]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <relExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( 
rule: 
matching: openpar [openpar, (, 62]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> <arithExpr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr 
rule: 
<relExpr>: <arithExpr> <relOp> <arithExpr> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr 
rule: 
matching: id [id, arr, 62]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <idnestFollowing> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ 
rule: 
<optIdnestFollowing>: <idnestFollowing> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ 
rule: 
<idnestFollowing>: [EPSILON: epsilon] <multiIndice> [CREATE_NODE: indices] [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> <indice> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ 
rule: 
<multiIndice>: <indice> <multiIndice> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> opensqbr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ 
rule: 
<indice>: opensqbr <arithExpr> closesqbr 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ 
rule: 
matching: opensqbr [opensqbr, [, 62]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j 
rule: 
matching: id [id, j, 62]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] 
rule: 
matching: closesqbr [closesqbr, ], 62]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > 
rule: 
<multiIndice>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> [CREATE_LEAF: gt] gt 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > 
rule: 
<relOp>: gt [CREATE_LEAF: gt] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> [CREATE_LEAF: gt] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > 
rule: 
matching: gt [gt, >, 62]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][arithExpr][gt]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][arithExpr][gt][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][arithExpr][gt][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr 
rule: 
matching: id [id, arr, 62]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][arithExpr][gt][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <idnestFollowing> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ 
rule: 
<optIdnestFollowing>: <idnestFollowing> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][arithExpr][gt][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ 
rule: 
<idnestFollowing>: [EPSILON: epsilon] <multiIndice> [CREATE_NODE: indices] [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][arithExpr][gt][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> <indice> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ 
rule: 
<multiIndice>: <indice> <multiIndice> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][arithExpr][gt][epsilon][epsilon][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> opensqbr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ 
rule: 
<indice>: opensqbr <arithExpr> closesqbr 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][arithExpr][gt][epsilon][epsilon][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ 
rule: 
matching: opensqbr [opensqbr, [, 62]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][arithExpr][gt][epsilon][epsilon][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][arithExpr][gt][epsilon][epsilon][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][arithExpr][gt][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][arithExpr][gt][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j 
rule: 
matching: id [id, j, 62]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][arithExpr][gt][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][arithExpr][gt][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][arithExpr][gt][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][arithExpr][gt][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> <addOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 
rule: 
<rightrecArithExpr>: <addOp> <term> <rightrecArithExpr> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][arithExpr][gt][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] plus 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 
rule: 
<addOp>: plus [CREATE_LEAF: plus] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][arithExpr][gt][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 
rule: 
matching: plus [plus, +, 62]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][arithExpr][gt][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][arithExpr][gt][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][term][plus]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][arithExpr][gt][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][term][plus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 
rule: 
matching: intnum [intnum, 1, 62]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][arithExpr][gt][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][term][plus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][arithExpr][gt][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][term][plus][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][arithExpr][gt][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][term][plus][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] 
rule: 
matching: closesqbr [closesqbr, ], 62]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][arithExpr][gt][epsilon][epsilon][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) 
rule: 
<multiIndice>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][arithExpr][gt][epsilon][epsilon][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][arithExpr][gt][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][arithExpr][gt][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][epsilon][arithExpr][gt][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) 
rule: 
matching: closepar [closepar, ), 62]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then 
rule: 
matching: then [then, then, 62]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> opencubr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { 
rule: 
<statBlock>: opencubr <multiStatement> closecubr 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { 
rule: 
matching: opencubr [opencubr, {, 62]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
rule: 
skipping
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
rule: 
skipping
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp 
rule: 
<multiStatement>: <statement> <multiStatement> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp 
rule: 
matching: id [id, temp, 64]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = 
rule: 
matching: assign [assign, =, 64]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][epsilon][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr 
rule: 
matching: id [id, arr, 64]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <idnestFollowing> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ 
rule: 
<optIdnestFollowing>: <idnestFollowing> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ 
rule: 
<idnestFollowing>: [EPSILON: epsilon] <multiIndice> [CREATE_NODE: indices] [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> <indice> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ 
rule: 
<multiIndice>: <indice> <multiIndice> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> opensqbr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ 
rule: 
<indice>: opensqbr <arithExpr> closesqbr 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ 
rule: 
matching: opensqbr [opensqbr, [, 64]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j 
rule: 
matching: id [id, j, 64]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] 
rule: 
matching: closesqbr [closesqbr, ], 64]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; 
rule: 
<multiIndice>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][epsilon][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; 
rule: 
matching: semi [semi, ;, 64]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
rule: 
skipping
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr 
rule: 
<multiStatement>: <statement> <multiStatement> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr 
rule: 
matching: id [id, arr, 65]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ 
rule: 
<optIdnestFollowing>: <idnestFollowing> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ 
rule: 
<idnestFollowing>: [EPSILON: epsilon] <multiIndice> [CREATE_NODE: indices] [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> <indice> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ 
rule: 
<multiIndice>: <indice> <multiIndice> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> opensqbr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ 
rule: 
<indice>: opensqbr <arithExpr> closesqbr 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ 
rule: 
matching: opensqbr [opensqbr, [, 65]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][epsilon][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j 
rule: 
matching: id [id, j, 65]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][epsilon][id][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] 
rule: 
matching: closesqbr [closesqbr, ], 65]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = 
rule: 
<multiIndice>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = 
rule: 
matching: assign [assign, =, 65]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr 
rule: 
matching: id [id, arr, 65]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <idnestFollowing> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ 
rule: 
<optIdnestFollowing>: <idnestFollowing> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ 
rule: 
<idnestFollowing>: [EPSILON: epsilon] <multiIndice> [CREATE_NODE: indices] [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> <indice> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ 
rule: 
<multiIndice>: <indice> <multiIndice> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> opensqbr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ 
rule: 
<indice>: opensqbr <arithExpr> closesqbr 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ 
rule: 
matching: opensqbr [opensqbr, [, 65]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j 
rule: 
matching: id [id, j, 65]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> <addOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 
rule: 
<rightrecArithExpr>: <addOp> <term> <rightrecArithExpr> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] plus 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 
rule: 
<addOp>: plus [CREATE_LEAF: plus] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 
rule: 
matching: plus [plus, +, 65]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][term][plus]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][term][plus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 
rule: 
matching: intnum [intnum, 1, 65]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][term][plus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][term][plus][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][term][plus][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] 
rule: 
matching: closesqbr [closesqbr, ], 65]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; 
rule: 
<multiIndice>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][epsilon][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; 
rule: 
matching: semi [semi, ;, 65]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
rule: 
skipping
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr 
rule: 
<multiStatement>: <statement> <multiStatement> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr 
rule: 
matching: id [id, arr, 66]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][assignStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ 
rule: 
<optIdnestFollowing>: <idnestFollowing> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][assignStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ 
rule: 
<idnestFollowing>: [EPSILON: epsilon] <multiIndice> [CREATE_NODE: indices] [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][assignStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> <indice> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ 
rule: 
<multiIndice>: <indice> <multiIndice> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> opensqbr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ 
rule: 
<indice>: opensqbr <arithExpr> closesqbr 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ 
rule: 
matching: opensqbr [opensqbr, [, 66]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j 
rule: 
matching: id [id, j, 66]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> <addOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 
rule: 
<rightrecArithExpr>: <addOp> <term> <rightrecArithExpr> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] plus 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 
rule: 
<addOp>: plus [CREATE_LEAF: plus] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 
rule: 
matching: plus [plus, +, 66]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][term][plus]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][term][plus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 
rule: 
matching: intnum [intnum, 1, 66]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][term][plus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][term][plus][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][term][plus][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] 
rule: 
matching: closesqbr [closesqbr, ], 66]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = 
rule: 
<multiIndice>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = 
rule: 
matching: assign [assign, =, 66]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][assignStatement][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp 
rule: 
matching: id [id, temp, 66]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][assignStatement][epsilon][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; 
rule: 
matching: semi [semi, ;, 66]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
rule: 
skipping
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} 
rule: 
<multiStatement>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} 
rule: 
matching: closecubr [closecubr, }, 67]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][epsilon][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else 
rule: 
matching: else [else, else, 67]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][thenStatements]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
rule: 
<statBlock>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifCondition][thenStatements][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
rule: 
matching: semi [semi, ;, 67]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j 
rule: 
<multiStatement>: <statement> <multiStatement> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j 
rule: 
matching: id [id, j, 68]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = 
rule: 
matching: assign [assign, =, 68]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifStatement][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifStatement][epsilon][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j 
rule: 
matching: id [id, j, 68]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> <addOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 
rule: 
<rightrecArithExpr>: <addOp> <term> <rightrecArithExpr> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] plus 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 
rule: 
<addOp>: plus [CREATE_LEAF: plus] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 
rule: 
matching: plus [plus, +, 68]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifStatement][epsilon][idIndice][epsilon][epsilon][term][plus]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 
rule: 
matching: intnum [intnum, 1, 68]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifStatement][epsilon][idIndice][epsilon][epsilon][term][plus][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifStatement][epsilon][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; 
rule: 
matching: semi [semi, ;, 68]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
rule: 
skipping
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} 
rule: 
<multiStatement>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} 
rule: 
matching: closecubr [closecubr, }, 69]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileCondition][epsilon][ifStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
rule: 
matching: semi [semi, ;, 69]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i 
rule: 
<multiStatement>: <statement> <multiStatement> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i 
rule: 
matching: id [id, i, 70]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = 
rule: 
matching: assign [assign, =, 70]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileStatement][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileStatement][epsilon][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i 
rule: 
matching: id [id, i, 70]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> <addOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 
rule: 
<rightrecArithExpr>: <addOp> <term> <rightrecArithExpr> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] plus 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 
rule: 
<addOp>: plus [CREATE_LEAF: plus] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 
rule: 
matching: plus [plus, +, 70]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileStatement][epsilon][idIndice][epsilon][epsilon][term][plus]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 
rule: 
matching: intnum [intnum, 1, 70]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileStatement][epsilon][idIndice][epsilon][epsilon][term][plus][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileStatement][epsilon][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; 
rule: 
matching: semi [semi, ;, 70]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
rule: 
skipping
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} 
rule: 
<multiStatement>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} 
rule: 
matching: closecubr [closecubr, }, 71]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileCondition][epsilon][assignStatement][whileStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
rule: 
matching: semi [semi, ;, 71]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
rule: 
<multiLocalVarDeclOrStmt>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
rule: 
matching: closecubr [closecubr, }, 72]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][whileStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
rule: 
skipping
semantic stack: 
[epsilon][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <classDeclOrFuncDef> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function 
rule: 
<multiClassDeclOrFuncDef>: <classDeclOrFuncDef> <multiClassDeclOrFuncDef> 
semantic stack: 
[epsilon][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <funcDef> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function 
rule: 
<classDeclOrFuncDef>: <funcDef> 
semantic stack: 
[epsilon][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHead> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function 
rule: 
<funcDef>: <funcHead> <funcBody> [CREATE_NODE: function] 
semantic stack: 
[epsilon][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] id function [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function 
rule: 
<funcHead>: [EPSILON: epsilon] function id [CREATE_LEAF: id] <funcHeadFollowing> 
semantic stack: 
[epsilon][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] id 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function 
rule: 
matching: function [function, function, 75]
semantic stack: 
[epsilon][function][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray 
rule: 
matching: id [id, printArray, 75]
semantic stack: 
[epsilon][function][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( 
rule: 
<funcHeadFollowing>: openpar [EPSILON: epsilon] <fParams> [CREATE_NODE: fParams] closepar returntype <returnType> [CREATE_NODE: normalFunctionHead] 
semantic stack: 
[epsilon][function][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( 
rule: 
matching: openpar [openpar, (, 75]
semantic stack: 
[epsilon][function][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr 
rule: 
<fParams>: [EPSILON: epsilon] id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: fParam] <multiFParamsTail> 
semantic stack: 
[epsilon][function][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr 
rule: 
matching: id [id, arr, 75]
semantic stack: 
[epsilon][function][epsilon][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : 
rule: 
matching: colon [colon, :, 75]
semantic stack: 
[epsilon][function][epsilon][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: integer] integer 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer 
rule: 
<type>: integer [CREATE_LEAF: integer] 
semantic stack: 
[epsilon][function][epsilon][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: integer] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer 
rule: 
matching: integer [integer, integer, 75]
semantic stack: 
[epsilon][function][epsilon][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> <arraySize> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 
rule: 
<multiArraySize>: <arraySize> <multiArraySize> 
semantic stack: 
[epsilon][function][epsilon][id][epsilon][epsilon][id][integer][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> <arraySizeParam> [EPSILON: epsilon] opensqbr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 
rule: 
<arraySize>: opensqbr [EPSILON: epsilon] <arraySizeParam> 
semantic stack: 
[epsilon][function][epsilon][id][epsilon][epsilon][id][integer][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> <arraySizeParam> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 
rule: 
matching: opensqbr [opensqbr, [, 75]
semantic stack: 
[epsilon][function][epsilon][id][epsilon][epsilon][id][integer][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [CREATE_NODE: arraySize] closesqbr [CREATE_LEAF: intNum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 
rule: 
<arraySizeParam>: intnum [CREATE_LEAF: intNum] closesqbr [CREATE_NODE: arraySize] 
semantic stack: 
[epsilon][function][epsilon][id][epsilon][epsilon][id][integer][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [CREATE_NODE: arraySize] closesqbr [CREATE_LEAF: intNum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 
rule: 
matching: intnum [intnum, 7, 75]
semantic stack: 
[epsilon][function][epsilon][id][epsilon][epsilon][id][integer][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [CREATE_NODE: arraySize] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] 
rule: 
matching: closesqbr [closesqbr, ], 75]
semantic stack: 
[epsilon][function][epsilon][id][epsilon][epsilon][id][integer][epsilon][epsilon][intNum]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][function][epsilon][id][epsilon][epsilon][id][integer][epsilon][arraySize]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> <fParamsTail> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , 
rule: 
<multiFParamsTail>: <fParamsTail> <multiFParamsTail> 
semantic stack: 
[epsilon][function][epsilon][id][epsilon][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id comma [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , 
rule: 
<fParamsTail>: [EPSILON: epsilon] comma id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: fParam] 
semantic stack: 
[epsilon][function][epsilon][id][epsilon][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , 
rule: 
matching: comma [comma, ,, 75]
semantic stack: 
[epsilon][function][epsilon][id][epsilon][fParam][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size 
rule: 
matching: id [id, size, 75]
semantic stack: 
[epsilon][function][epsilon][id][epsilon][fParam][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : 
rule: 
matching: colon [colon, :, 75]
semantic stack: 
[epsilon][function][epsilon][id][epsilon][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: integer] integer 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer 
rule: 
<type>: integer [CREATE_LEAF: integer] 
semantic stack: 
[epsilon][function][epsilon][id][epsilon][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: integer] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer 
rule: 
matching: integer [integer, integer, 75]
semantic stack: 
[epsilon][function][epsilon][id][epsilon][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][function][epsilon][id][epsilon][fParam][epsilon][id][integer][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) 
rule: 
<multiFParamsTail>: 
semantic stack: 
[epsilon][function][epsilon][id][epsilon][fParam][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) 
rule: 
matching: closepar [closepar, ), 75]
semantic stack: 
[epsilon][function][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => 
rule: 
matching: returntype [returntype, =>, 75]
semantic stack: 
[epsilon][function][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] [CREATE_NODE: returnType] void 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void 
rule: 
<returnType>: void [CREATE_NODE: returnType] 
semantic stack: 
[epsilon][function][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] [CREATE_NODE: returnType] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void 
rule: 
matching: void [void, void, 75]
semantic stack: 
[epsilon][function][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
rule: 
skipping
semantic stack: 
[epsilon][function][normalFunctionHead]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> opencubr [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
rule: 
<funcBody>: [EPSILON: epsilon] opencubr <multiLocalVarDeclOrStmt> closecubr [CREATE_NODE: functionBody] 
semantic stack: 
[epsilon][function][normalFunctionHead]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
rule: 
matching: opencubr [opencubr, {, 76]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDecl> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar 
rule: 
<localVarDeclOrStmt>: <localVarDecl> 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id localvar [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar 
rule: 
<localVarDecl>: [EPSILON: epsilon] localvar id [CREATE_LEAF: id] colon <type> <localVarDeclFollowing> [CREATE_NODE: localVarDecl] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar 
rule: 
matching: localvar [localvar, localvar, 77]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n 
rule: 
matching: id [id, n, 77]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : 
rule: 
matching: colon [colon, :, 77]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: integer] integer 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer 
rule: 
<type>: integer [CREATE_LEAF: integer] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: integer] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer 
rule: 
matching: integer [integer, integer, 77]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; 
rule: 
<localVarDeclFollowing>: [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] semi 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][epsilon][id][integer]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][epsilon][id][integer][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; 
rule: 
matching: semi [semi, ;, 77]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][epsilon][id][integer][arraySizes]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
rule: 
skipping
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDecl> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar 
rule: 
<localVarDeclOrStmt>: <localVarDecl> 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id localvar [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar 
rule: 
<localVarDecl>: [EPSILON: epsilon] localvar id [CREATE_LEAF: id] colon <type> <localVarDeclFollowing> [CREATE_NODE: localVarDecl] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar 
rule: 
matching: localvar [localvar, localvar, 78]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i 
rule: 
matching: id [id, i, 78]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : 
rule: 
matching: colon [colon, :, 78]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: integer] integer 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer 
rule: 
<type>: integer [CREATE_LEAF: integer] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: integer] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer 
rule: 
matching: integer [integer, integer, 78]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; 
rule: 
<localVarDeclFollowing>: [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] semi 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][integer]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][integer][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; 
rule: 
matching: semi [semi, ;, 78]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][epsilon][id][integer][arraySizes]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
rule: 
skipping
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n 
rule: 
matching: id [id, n, 79]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = 
rule: 
matching: assign [assign, =, 79]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size 
rule: 
matching: id [id, size, 79]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; 
rule: 
matching: semi [semi, ;, 79]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
rule: 
skipping
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i 
rule: 
matching: id [id, i, 80]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 
rule: 
matching: assign [assign, =, 80]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 
rule: 
matching: intnum [intnum, 0, 80]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][epsilon][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; 
rule: 
matching: semi [semi, ;, 80]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
rule: 
skipping
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <relExpr> [EPSILON: epsilon] openpar while 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while 
rule: 
<statement>: while openpar [EPSILON: epsilon] <relExpr> [CREATE_NODE: whileCondition] closepar [EPSILON: epsilon] <statBlock> [CREATE_NODE: whileBlockStatements] [CREATE_NODE: whileStatement] semi 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <relExpr> [EPSILON: epsilon] openpar 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while 
rule: 
matching: while [while, while, 81]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <relExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( 
rule: 
matching: openpar [openpar, (, 81]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> <arithExpr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i 
rule: 
<relExpr>: <arithExpr> <relOp> <arithExpr> 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i 
rule: 
matching: id [id, i, 81]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> [CREATE_LEAF: lt] lt 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < 
rule: 
<relOp>: lt [CREATE_LEAF: lt] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> [CREATE_LEAF: lt] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < 
rule: 
matching: lt [lt, <, 81]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][arithExpr][lt]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][arithExpr][lt][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][arithExpr][lt][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n 
rule: 
matching: id [id, n, 81]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][arithExpr][lt][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][arithExpr][lt][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][arithExpr][lt][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][arithExpr][lt][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][arithExpr][lt][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) 
rule: 
matching: closepar [closepar, ), 81]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> opencubr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { 
rule: 
<statBlock>: opencubr <multiStatement> closecubr 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { 
rule: 
matching: opencubr [opencubr, {, 81]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
rule: 
skipping
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write 
rule: 
<multiStatement>: <statement> <multiStatement> 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar <expr> openpar write 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write 
rule: 
<statement>: write openpar <expr> closepar [CREATE_NODE: writeStatement] semi 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar <expr> openpar 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write 
rule: 
matching: write [write, write, 82]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( 
rule: 
matching: openpar [openpar, (, 82]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr 
rule: 
matching: id [id, arr, 82]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <idnestFollowing> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ 
rule: 
<optIdnestFollowing>: <idnestFollowing> 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ 
rule: 
<idnestFollowing>: [EPSILON: epsilon] <multiIndice> [CREATE_NODE: indices] [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> <indice> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ 
rule: 
<multiIndice>: <indice> <multiIndice> 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> opensqbr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ 
rule: 
<indice>: opensqbr <arithExpr> closesqbr 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ 
rule: 
matching: opensqbr [opensqbr, [, 82]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i 
rule: 
matching: id [id, i, 82]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] 
rule: 
matching: closesqbr [closesqbr, ], 82]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) 
rule: 
<multiIndice>: 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) 
rule: 
matching: closepar [closepar, ), 82]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; 
rule: 
matching: semi [semi, ;, 82]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
rule: 
skipping
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i 
rule: 
<multiStatement>: <statement> <multiStatement> 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i 
rule: 
matching: id [id, i, 83]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = 
rule: 
matching: assign [assign, =, 83]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i 
rule: 
matching: id [id, i, 83]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> <addOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 
rule: 
<rightrecArithExpr>: <addOp> <term> <rightrecArithExpr> 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] plus 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 
rule: 
<addOp>: plus [CREATE_LEAF: plus] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 
rule: 
matching: plus [plus, +, 83]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice][epsilon][epsilon][term][plus]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 
rule: 
matching: intnum [intnum, 1, 83]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice][epsilon][epsilon][term][plus][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; 
rule: 
matching: semi [semi, ;, 83]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][writeStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
rule: 
skipping
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][writeStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} 
rule: 
<multiStatement>: 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][writeStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} 
rule: 
matching: closecubr [closecubr, }, 84]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileCondition][epsilon][writeStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
rule: 
matching: semi [semi, ;, 84]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
rule: 
<multiLocalVarDeclOrStmt>: 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
rule: 
matching: closecubr [closecubr, }, 85]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][localVarDecl][localVarDecl][assignStatement][assignStatement][whileStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
rule: 
skipping
semantic stack: 
[epsilon][function][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <classDeclOrFuncDef> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function 
rule: 
<multiClassDeclOrFuncDef>: <classDeclOrFuncDef> <multiClassDeclOrFuncDef> 
semantic stack: 
[epsilon][function][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <funcDef> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function 
rule: 
<classDeclOrFuncDef>: <funcDef> 
semantic stack: 
[epsilon][function][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHead> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function 
rule: 
<funcDef>: <funcHead> <funcBody> [CREATE_NODE: function] 
semantic stack: 
[epsilon][function][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] id function [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function 
rule: 
<funcHead>: [EPSILON: epsilon] function id [CREATE_LEAF: id] <funcHeadFollowing> 
semantic stack: 
[epsilon][function][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] id 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function 
rule: 
matching: function [function, function, 88]
semantic stack: 
[epsilon][function][function][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main 
rule: 
matching: id [id, main, 88]
semantic stack: 
[epsilon][function][function][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( 
rule: 
<funcHeadFollowing>: openpar [EPSILON: epsilon] <fParams> [CREATE_NODE: fParams] closepar returntype <returnType> [CREATE_NODE: normalFunctionHead] 
semantic stack: 
[epsilon][function][function][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( 
rule: 
matching: openpar [openpar, (, 88]
semantic stack: 
[epsilon][function][function][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) 
rule: 
<fParams>: 
semantic stack: 
[epsilon][function][function][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) 
rule: 
matching: closepar [closepar, ), 88]
semantic stack: 
[epsilon][function][function][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
rule: 
matching: returntype [returntype, =>, 88]
semantic stack: 
[epsilon][function][function][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] [CREATE_NODE: returnType] void 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void 
rule: 
<returnType>: void [CREATE_NODE: returnType] 
semantic stack: 
[epsilon][function][function][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] [CREATE_NODE: returnType] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void 
rule: 
matching: void [void, void, 89]
semantic stack: 
[epsilon][function][function][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> opencubr [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
rule: 
<funcBody>: [EPSILON: epsilon] opencubr <multiLocalVarDeclOrStmt> closecubr [CREATE_NODE: functionBody] 
semantic stack: 
[epsilon][function][function][normalFunctionHead]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
rule: 
matching: opencubr [opencubr, {, 89]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDecl> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar 
rule: 
<localVarDeclOrStmt>: <localVarDecl> 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id localvar [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar 
rule: 
<localVarDecl>: [EPSILON: epsilon] localvar id [CREATE_LEAF: id] colon <type> <localVarDeclFollowing> [CREATE_NODE: localVarDecl] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar 
rule: 
matching: localvar [localvar, localvar, 90]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr 
rule: 
matching: id [id, arr, 90]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : 
rule: 
matching: colon [colon, :, 90]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: integer] integer 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer 
rule: 
<type>: integer [CREATE_LEAF: integer] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: integer] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer 
rule: 
matching: integer [integer, integer, 90]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 
rule: 
<localVarDeclFollowing>: [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] semi 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][epsilon][id][integer]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] <multiArraySize> <arraySize> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 
rule: 
<multiArraySize>: <arraySize> <multiArraySize> 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][epsilon][id][integer][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] <multiArraySize> <arraySizeParam> [EPSILON: epsilon] opensqbr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 
rule: 
<arraySize>: opensqbr [EPSILON: epsilon] <arraySizeParam> 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][epsilon][id][integer][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] <multiArraySize> <arraySizeParam> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 
rule: 
matching: opensqbr [opensqbr, [, 90]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][epsilon][id][integer][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] <multiArraySize> [CREATE_NODE: arraySize] closesqbr [CREATE_LEAF: intNum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 
rule: 
<arraySizeParam>: intnum [CREATE_LEAF: intNum] closesqbr [CREATE_NODE: arraySize] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][epsilon][id][integer][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] <multiArraySize> [CREATE_NODE: arraySize] closesqbr [CREATE_LEAF: intNum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 
rule: 
matching: intnum [intnum, 7, 90]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][epsilon][id][integer][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] <multiArraySize> [CREATE_NODE: arraySize] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] 
rule: 
matching: closesqbr [closesqbr, ], 90]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][epsilon][id][integer][epsilon][epsilon][intNum]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][epsilon][id][integer][epsilon][arraySize]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; 
rule: 
matching: semi [semi, ;, 90]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][epsilon][id][integer][arraySizes]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
rule: 
skipping
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr 
rule: 
matching: id [id, arr, 91]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 
rule: 
<optIdnestFollowing>: <idnestFollowing> 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 
rule: 
<idnestFollowing>: [EPSILON: epsilon] <multiIndice> [CREATE_NODE: indices] [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> <indice> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 
rule: 
<multiIndice>: <indice> <multiIndice> 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> opensqbr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 
rule: 
<indice>: opensqbr <arithExpr> closesqbr 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 
rule: 
matching: opensqbr [opensqbr, [, 91]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][epsilon][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 
rule: 
matching: intnum [intnum, 0, 91]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][epsilon][id][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][epsilon][id][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] 
rule: 
matching: closesqbr [closesqbr, ], 91]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 
rule: 
<multiIndice>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 
rule: 
matching: assign [assign, =, 91]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 
rule: 
matching: intnum [intnum, 64, 91]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][idIndice][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][epsilon][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; 
rule: 
matching: semi [semi, ;, 91]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
rule: 
skipping
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr 
rule: 
matching: id [id, arr, 92]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 
rule: 
<optIdnestFollowing>: <idnestFollowing> 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 
rule: 
<idnestFollowing>: [EPSILON: epsilon] <multiIndice> [CREATE_NODE: indices] [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> <indice> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 
rule: 
<multiIndice>: <indice> <multiIndice> 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> opensqbr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 
rule: 
<indice>: opensqbr <arithExpr> closesqbr 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 
rule: 
matching: opensqbr [opensqbr, [, 92]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][epsilon][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 
rule: 
matching: intnum [intnum, 1, 92]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][epsilon][id][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] 
rule: 
matching: closesqbr [closesqbr, ], 92]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 
rule: 
<multiIndice>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 
rule: 
matching: assign [assign, =, 92]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 
rule: 
matching: intnum [intnum, 34, 92]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][epsilon][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; 
rule: 
matching: semi [semi, ;, 92]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
rule: 
skipping
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr 
rule: 
matching: id [id, arr, 93]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 
rule: 
<optIdnestFollowing>: <idnestFollowing> 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 
rule: 
<idnestFollowing>: [EPSILON: epsilon] <multiIndice> [CREATE_NODE: indices] [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> <indice> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 
rule: 
<multiIndice>: <indice> <multiIndice> 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> opensqbr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 
rule: 
<indice>: opensqbr <arithExpr> closesqbr 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 
rule: 
matching: opensqbr [opensqbr, [, 93]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 
rule: 
matching: intnum [intnum, 2, 93]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] 
rule: 
matching: closesqbr [closesqbr, ], 93]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 
rule: 
<multiIndice>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 
rule: 
matching: assign [assign, =, 93]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 
rule: 
matching: intnum [intnum, 25, 93]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; 
rule: 
matching: semi [semi, ;, 93]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
rule: 
skipping
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr 
rule: 
matching: id [id, arr, 94]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 
rule: 
<optIdnestFollowing>: <idnestFollowing> 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 
rule: 
<idnestFollowing>: [EPSILON: epsilon] <multiIndice> [CREATE_NODE: indices] [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> <indice> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 
rule: 
<multiIndice>: <indice> <multiIndice> 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> opensqbr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 
rule: 
<indice>: opensqbr <arithExpr> closesqbr 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 
rule: 
matching: opensqbr [opensqbr, [, 94]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 
rule: 
matching: intnum [intnum, 3, 94]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] 
rule: 
matching: closesqbr [closesqbr, ], 94]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 
rule: 
<multiIndice>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 
rule: 
matching: assign [assign, =, 94]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 
rule: 
matching: intnum [intnum, 12, 94]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; 
rule: 
matching: semi [semi, ;, 94]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
rule: 
skipping
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr 
rule: 
matching: id [id, arr, 95]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 
rule: 
<optIdnestFollowing>: <idnestFollowing> 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 
rule: 
<idnestFollowing>: [EPSILON: epsilon] <multiIndice> [CREATE_NODE: indices] [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> <indice> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 
rule: 
<multiIndice>: <indice> <multiIndice> 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> opensqbr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 
rule: 
<indice>: opensqbr <arithExpr> closesqbr 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 
rule: 
matching: opensqbr [opensqbr, [, 95]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 
rule: 
matching: intnum [intnum, 4, 95]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] 
rule: 
matching: closesqbr [closesqbr, ], 95]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 
rule: 
<multiIndice>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 
rule: 
matching: assign [assign, =, 95]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 
rule: 
matching: intnum [intnum, 22, 95]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; 
rule: 
matching: semi [semi, ;, 95]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
rule: 
skipping
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr 
rule: 
matching: id [id, arr, 96]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 
rule: 
<optIdnestFollowing>: <idnestFollowing> 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 
rule: 
<idnestFollowing>: [EPSILON: epsilon] <multiIndice> [CREATE_NODE: indices] [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> <indice> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 
rule: 
<multiIndice>: <indice> <multiIndice> 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> opensqbr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 
rule: 
<indice>: opensqbr <arithExpr> closesqbr 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 
rule: 
matching: opensqbr [opensqbr, [, 96]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 
rule: 
matching: intnum [intnum, 5, 96]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] 
rule: 
matching: closesqbr [closesqbr, ], 96]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 
rule: 
<multiIndice>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 
rule: 
matching: assign [assign, =, 96]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 
rule: 
matching: intnum [intnum, 11, 96]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; 
rule: 
matching: semi [semi, ;, 96]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
rule: 
skipping
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr 
rule: 
matching: id [id, arr, 97]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 
rule: 
<optIdnestFollowing>: <idnestFollowing> 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 
rule: 
<idnestFollowing>: [EPSILON: epsilon] <multiIndice> [CREATE_NODE: indices] [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> <indice> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 
rule: 
<multiIndice>: <indice> <multiIndice> 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> opensqbr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 
rule: 
<indice>: opensqbr <arithExpr> closesqbr 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 
rule: 
matching: opensqbr [opensqbr, [, 97]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 
rule: 
matching: intnum [intnum, 6, 97]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] 
rule: 
matching: closesqbr [closesqbr, ], 97]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 
rule: 
<multiIndice>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 
rule: 
matching: assign [assign, =, 97]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 
rule: 
matching: intnum [intnum, 90, 97]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; 
rule: 
matching: semi [semi, ;, 97]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
rule: 
skipping
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar <expr> openpar write 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write 
rule: 
<statement>: write openpar <expr> closepar [CREATE_NODE: writeStatement] semi 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar <expr> openpar 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write 
rule: 
matching: write [write, write, 98]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( 
rule: 
matching: openpar [openpar, (, 98]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr 
rule: 
matching: id [id, arr, 98]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <idnestFollowing> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 
rule: 
<optIdnestFollowing>: <idnestFollowing> 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 
rule: 
<idnestFollowing>: [EPSILON: epsilon] <multiIndice> [CREATE_NODE: indices] [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> <indice> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 
rule: 
<multiIndice>: <indice> <multiIndice> 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> opensqbr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 
rule: 
<indice>: opensqbr <arithExpr> closesqbr 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 
rule: 
matching: opensqbr [opensqbr, [, 98]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 
rule: 
matching: intnum [intnum, 6, 98]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] 
rule: 
matching: closesqbr [closesqbr, ], 98]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] ) 
rule: 
<multiIndice>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] ) 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] ) 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] ) 
rule: 
matching: closepar [closepar, ), 98]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] ) ; 
rule: 
matching: semi [semi, ;, 98]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] ) ; 
printArray 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] ) ; 
printArray 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] ) ; 
printArray 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] ) ; 
printArray 
rule: 
matching: id [id, printArray, 99]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] ) ; 
printArray ( 
rule: 
<optIdnestFollowing>: <idnestFollowing> 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: funcCall] closepar <aParams> openpar 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] ) ; 
printArray ( 
rule: 
<idnestFollowing>: openpar <aParams> closepar [CREATE_NODE: funcCall] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: funcCall] closepar <aParams> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] ) ; 
printArray ( 
rule: 
matching: openpar [openpar, (, 99]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] ) ; 
printArray ( arr 
rule: 
<aParams>: <expr> <multiAParamsTail> 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] ) ; 
printArray ( arr 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] ) ; 
printArray ( arr 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] ) ; 
printArray ( arr 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][epsilon][epsilon][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] ) ; 
printArray ( arr 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] ) ; 
printArray ( arr 
rule: 
matching: id [id, arr, 99]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] ) ; 
printArray ( arr , 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] ) ; 
printArray ( arr , 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] ) ; 
printArray ( arr , 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] ) ; 
printArray ( arr , 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][epsilon][epsilon][id][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] ) ; 
printArray ( arr , 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> <aParamsTail> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] ) ; 
printArray ( arr , 
rule: 
<multiAParamsTail>: <aParamsTail> <multiAParamsTail> 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][epsilon][epsilon][id][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> <expr> comma 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] ) ; 
printArray ( arr , 
rule: 
<aParamsTail>: comma <expr> 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][epsilon][epsilon][id][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] ) ; 
printArray ( arr , 
rule: 
matching: comma [comma, ,, 99]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][epsilon][epsilon][id][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] ) ; 
printArray ( arr , 7 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][epsilon][epsilon][id][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] ) ; 
printArray ( arr , 7 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][epsilon][epsilon][id][expr][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] ) ; 
printArray ( arr , 7 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][epsilon][epsilon][id][expr][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] ) ; 
printArray ( arr , 7 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][epsilon][epsilon][id][expr][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] ) ; 
printArray ( arr , 7 
rule: 
matching: intnum [intnum, 7, 99]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][epsilon][epsilon][id][expr][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] ) ; 
printArray ( arr , 7 ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][epsilon][epsilon][id][expr][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] ) ; 
printArray ( arr , 7 ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][epsilon][epsilon][id][expr][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] ) ; 
printArray ( arr , 7 ) 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][epsilon][epsilon][id][expr][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: funcCall] closepar 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] ) ; 
printArray ( arr , 7 ) 
rule: 
<multiAParamsTail>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][epsilon][epsilon][id][expr][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: funcCall] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] ) ; 
printArray ( arr , 7 ) 
rule: 
matching: closepar [closepar, ), 99]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][epsilon][epsilon][id][expr][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] ) ; 
printArray ( arr , 7 ) ; 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][epsilon][funcCall]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: functionCallStatement] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] ) ; 
printArray ( arr , 7 ) ; 
rule: 
<functionCallOrAssignStat>: [CREATE_NODE: functionCallStatement] 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][epsilon][funcCall]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] ) ; 
printArray ( arr , 7 ) ; 
rule: 
matching: semi [semi, ;, 99]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][functionCallStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] ) ; 
printArray ( arr , 7 ) ; // 2.1, 2.2 
rule: 
skipping
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][functionCallStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] ) ; 
printArray ( arr , 7 ) ; // 2.1, 2.2 
/* assumes that the array is passed as a reference */ 
rule: 
skipping
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][functionCallStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] ) ; 
printArray ( arr , 7 ) ; // 2.1, 2.2 
/* assumes that the array is passed as a reference */ 
// bubbleSort(arr, 7);                                      // 2.1, 2.2 
rule: 
skipping
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][functionCallStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] ) ; 
printArray ( arr , 7 ) ; // 2.1, 2.2 
/* assumes that the array is passed as a reference */ 
// bubbleSort(arr, 7);                                      // 2.1, 2.2 
// printArray(arr, 7);                                      // 2.1, 2.2 
rule: 
skipping
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][functionCallStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] ) ; 
printArray ( arr , 7 ) ; // 2.1, 2.2 
/* assumes that the array is passed as a reference */ 
// bubbleSort(arr, 7);                                      // 2.1, 2.2 
// printArray(arr, 7);                                      // 2.1, 2.2 
} 
rule: 
<multiLocalVarDeclOrStmt>: 
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][functionCallStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] ) ; 
printArray ( arr , 7 ) ; // 2.1, 2.2 
/* assumes that the array is passed as a reference */ 
// bubbleSort(arr, 7);                                      // 2.1, 2.2 
// printArray(arr, 7);                                      // 2.1, 2.2 
} 
rule: 
matching: closecubr [closecubr, }, 103]
semantic stack: 
[epsilon][function][function][normalFunctionHead][epsilon][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][functionCallStatement]
-----------------------------------------------------------------------
stack: 
<$> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |     |  X  | 
// 1.4: |     |  X  | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |     |  X  | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  | 
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
/* sort the array */ 
function bubbleSort ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
localvar j : integer ; // 1.1 
localvar temp : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1   
j = 0 ; // 3.1 
temp = 0 ; // 3.1 
while ( i < n - 1 ) { // 3.3, 5.1 
j = 0 ; // 3.1 
while ( j < n - i - 1 ) { // 3.3 
if ( arr [ j ] > arr [ j + 1 ] ) then { // 3.2, 4.1, 5.1, 5.2 
// swap temp and arr[i] 
temp = arr [ j ] ; // 3.1, 4.1, 5.2 
arr [ j ] = arr [ j + 1 ] ; // 3.1, 4.1, 5.2 
arr [ j + 1 ] = temp ; // 3.1, 4.1, 5.2 
} else ; 
j = j + 1 ; // 3.1, 5.1 
} ; 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
/* print the array */ 
function printArray ( arr : integer [ 7 ] , size : integer ) => void // 2.1, 2.2 
{ 
localvar n : integer ; // 1.1 
localvar i : integer ; // 1.1 
n = size ; // 3.1 
i = 0 ; // 3.1 
while ( i < n ) { // 3.3, 5.1 
write ( arr [ i ] ) ; // 3.4, 4.1, 5.2 
i = i + 1 ; // 3.1, 5.1 
} ; 
} 
// main funtion to test above 
function main ( ) => 
void { 
localvar arr : integer [ 7 ] ; // 1.1 
arr [ 0 ] = 64 ; // 3.1  
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
write ( arr [ 6 ] ) ; 
printArray ( arr , 7 ) ; // 2.1, 2.2 
/* assumes that the array is passed as a reference */ 
// bubbleSort(arr, 7);                                      // 2.1, 2.2 
// printArray(arr, 7);                                      // 2.1, 2.2 
} 
rule: 
<multiClassDeclOrFuncDef>: 
semantic stack: 
[program]
-----------------------------------------------------------------------
