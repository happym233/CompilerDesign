stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> <START> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
rule: 
skipping
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function 
rule: 
<START>: [EPSILON: epsilon] <multiClassDeclOrFuncDef> [CREATE_NODE: program] 
semantic stack: 

-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <classDeclOrFuncDef> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function 
rule: 
<multiClassDeclOrFuncDef>: <classDeclOrFuncDef> <multiClassDeclOrFuncDef> 
semantic stack: 
[epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <funcDef> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function 
rule: 
<classDeclOrFuncDef>: <funcDef> 
semantic stack: 
[epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHead> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function 
rule: 
<funcDef>: <funcHead> <funcBody> [CREATE_NODE: function] 
semantic stack: 
[epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] id function [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function 
rule: 
<funcHead>: [EPSILON: epsilon] function id [CREATE_LEAF: id] <funcHeadFollowing> 
semantic stack: 
[epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] id 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function 
rule: 
matching: function [function, function, 48]
semantic stack: 
[epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add 
rule: 
matching: id [id, add, 48]
semantic stack: 
[epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( 
rule: 
<funcHeadFollowing>: openpar [EPSILON: epsilon] <fParams> [CREATE_NODE: fParams] closepar returntype <returnType> [CREATE_NODE: normalFunctionHead] 
semantic stack: 
[epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( 
rule: 
matching: openpar [openpar, (, 48]
semantic stack: 
[epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x 
rule: 
<fParams>: [EPSILON: epsilon] id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: fParam] <multiFParamsTail> 
semantic stack: 
[epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x 
rule: 
matching: id [id, x, 48]
semantic stack: 
[epsilon][epsilon][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : 
rule: 
matching: colon [colon, :, 48]
semantic stack: 
[epsilon][epsilon][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: integer] integer 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer 
rule: 
<type>: integer [CREATE_LEAF: integer] 
semantic stack: 
[epsilon][epsilon][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: integer] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer 
rule: 
matching: integer [integer, integer, 48]
semantic stack: 
[epsilon][epsilon][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][epsilon][id][epsilon][epsilon][id][integer][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> <fParamsTail> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , 
rule: 
<multiFParamsTail>: <fParamsTail> <multiFParamsTail> 
semantic stack: 
[epsilon][epsilon][id][epsilon][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id comma [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , 
rule: 
<fParamsTail>: [EPSILON: epsilon] comma id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: fParam] 
semantic stack: 
[epsilon][epsilon][id][epsilon][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , 
rule: 
matching: comma [comma, ,, 48]
semantic stack: 
[epsilon][epsilon][id][epsilon][fParam][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y 
rule: 
matching: id [id, y, 48]
semantic stack: 
[epsilon][epsilon][id][epsilon][fParam][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : 
rule: 
matching: colon [colon, :, 48]
semantic stack: 
[epsilon][epsilon][id][epsilon][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: integer] integer 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer 
rule: 
<type>: integer [CREATE_LEAF: integer] 
semantic stack: 
[epsilon][epsilon][id][epsilon][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: integer] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer 
rule: 
matching: integer [integer, integer, 48]
semantic stack: 
[epsilon][epsilon][id][epsilon][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][epsilon][id][epsilon][fParam][epsilon][id][integer][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> <fParamsTail> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , 
rule: 
<multiFParamsTail>: <fParamsTail> <multiFParamsTail> 
semantic stack: 
[epsilon][epsilon][id][epsilon][fParam][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id comma [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , 
rule: 
<fParamsTail>: [EPSILON: epsilon] comma id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: fParam] 
semantic stack: 
[epsilon][epsilon][id][epsilon][fParam][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , 
rule: 
matching: comma [comma, ,, 48]
semantic stack: 
[epsilon][epsilon][id][epsilon][fParam][fParam][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z 
rule: 
matching: id [id, z, 48]
semantic stack: 
[epsilon][epsilon][id][epsilon][fParam][fParam][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : 
rule: 
matching: colon [colon, :, 48]
semantic stack: 
[epsilon][epsilon][id][epsilon][fParam][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: integer] integer 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer 
rule: 
<type>: integer [CREATE_LEAF: integer] 
semantic stack: 
[epsilon][epsilon][id][epsilon][fParam][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: integer] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer 
rule: 
matching: integer [integer, integer, 48]
semantic stack: 
[epsilon][epsilon][id][epsilon][fParam][fParam][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][epsilon][id][epsilon][fParam][fParam][epsilon][id][integer][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) 
rule: 
<multiFParamsTail>: 
semantic stack: 
[epsilon][epsilon][id][epsilon][fParam][fParam][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) 
rule: 
matching: closepar [closepar, ), 48]
semantic stack: 
[epsilon][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
rule: 
matching: returntype [returntype, =>, 48]
semantic stack: 
[epsilon][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] [CREATE_NODE: returnType] <type> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer 
rule: 
<returnType>: <type> [CREATE_NODE: returnType] 
semantic stack: 
[epsilon][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] [CREATE_NODE: returnType] [CREATE_LEAF: integer] integer 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer 
rule: 
<type>: integer [CREATE_LEAF: integer] 
semantic stack: 
[epsilon][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] [CREATE_NODE: returnType] [CREATE_LEAF: integer] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer 
rule: 
matching: integer [integer, integer, 49]
semantic stack: 
[epsilon][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> opencubr [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
rule: 
<funcBody>: [EPSILON: epsilon] opencubr <multiLocalVarDeclOrStmt> closecubr [CREATE_NODE: functionBody] 
semantic stack: 
[epsilon][normalFunctionHead]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
rule: 
matching: opencubr [opencubr, {, 49]
semantic stack: 
[epsilon][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar <expr> openpar return 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return 
rule: 
<statement>: return openpar <expr> closepar [CREATE_NODE: returnStatement] semi 
semantic stack: 
[epsilon][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar <expr> openpar 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return 
rule: 
matching: return [return, return, 50]
semantic stack: 
[epsilon][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( 
rule: 
matching: openpar [openpar, (, 50]
semantic stack: 
[epsilon][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 
rule: 
matching: id [id, multi2, 50]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <idnestFollowing> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( 
rule: 
<optIdnestFollowing>: <idnestFollowing> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <aParams> openpar 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( 
rule: 
<idnestFollowing>: openpar <aParams> closepar [CREATE_NODE: funcCall] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <aParams> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( 
rule: 
matching: openpar [openpar, (, 50]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x 
rule: 
<aParams>: <expr> <multiAParamsTail> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x 
rule: 
matching: id [id, x, 50]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) 
rule: 
<multiAParamsTail>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) 
rule: 
matching: closepar [closepar, ), 50]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][epsilon][funcCall]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> <addOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + 
rule: 
<rightrecArithExpr>: <addOp> <term> <rightrecArithExpr> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] plus 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + 
rule: 
<addOp>: plus [CREATE_LEAF: plus] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + 
rule: 
matching: plus [plus, +, 50]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][epsilon][term][plus]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][epsilon][term][plus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y 
rule: 
matching: id [id, y, 50]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][epsilon][term][plus][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][epsilon][term][plus][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][epsilon][term][plus][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][epsilon][term][plus][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> <addOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + 
rule: 
<rightrecArithExpr>: <addOp> <term> <rightrecArithExpr> 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][epsilon][term][plus][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] plus 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + 
rule: 
<addOp>: plus [CREATE_LEAF: plus] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][epsilon][term][plus][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + 
rule: 
matching: plus [plus, +, 50]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][epsilon][term][plus][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][epsilon][term][plus][term][plus]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][epsilon][term][plus][term][plus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z 
rule: 
matching: id [id, z, 50]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][epsilon][term][plus][term][plus][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][epsilon][term][plus][term][plus][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][epsilon][term][plus][term][plus][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][epsilon][term][plus][term][plus][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][epsilon][term][plus][term][plus][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) 
rule: 
matching: closepar [closepar, ), 50]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
rule: 
matching: semi [semi, ;, 50]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][returnStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
rule: 
<multiLocalVarDeclOrStmt>: 
semantic stack: 
[epsilon][normalFunctionHead][epsilon][returnStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
rule: 
matching: closecubr [closecubr, }, 51]
semantic stack: 
[epsilon][normalFunctionHead][epsilon][returnStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <classDeclOrFuncDef> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function 
rule: 
<multiClassDeclOrFuncDef>: <classDeclOrFuncDef> <multiClassDeclOrFuncDef> 
semantic stack: 
[epsilon][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <funcDef> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function 
rule: 
<classDeclOrFuncDef>: <funcDef> 
semantic stack: 
[epsilon][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHead> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function 
rule: 
<funcDef>: <funcHead> <funcBody> [CREATE_NODE: function] 
semantic stack: 
[epsilon][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] id function [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function 
rule: 
<funcHead>: [EPSILON: epsilon] function id [CREATE_LEAF: id] <funcHeadFollowing> 
semantic stack: 
[epsilon][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] id 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function 
rule: 
matching: function [function, function, 53]
semantic stack: 
[epsilon][function][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 
rule: 
matching: id [id, multi2, 53]
semantic stack: 
[epsilon][function][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( 
rule: 
<funcHeadFollowing>: openpar [EPSILON: epsilon] <fParams> [CREATE_NODE: fParams] closepar returntype <returnType> [CREATE_NODE: normalFunctionHead] 
semantic stack: 
[epsilon][function][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( 
rule: 
matching: openpar [openpar, (, 53]
semantic stack: 
[epsilon][function][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x 
rule: 
<fParams>: [EPSILON: epsilon] id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: fParam] <multiFParamsTail> 
semantic stack: 
[epsilon][function][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x 
rule: 
matching: id [id, x, 53]
semantic stack: 
[epsilon][function][epsilon][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : 
rule: 
matching: colon [colon, :, 53]
semantic stack: 
[epsilon][function][epsilon][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: integer] integer 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer 
rule: 
<type>: integer [CREATE_LEAF: integer] 
semantic stack: 
[epsilon][function][epsilon][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: integer] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer 
rule: 
matching: integer [integer, integer, 53]
semantic stack: 
[epsilon][function][epsilon][id][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <multiFParamsTail> [CREATE_NODE: fParam] [CREATE_NODE: arraySizes] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][function][epsilon][id][epsilon][epsilon][id][integer][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) 
rule: 
<multiFParamsTail>: 
semantic stack: 
[epsilon][function][epsilon][id][epsilon][fParam]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) 
rule: 
matching: closepar [closepar, ), 53]
semantic stack: 
[epsilon][function][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
rule: 
matching: returntype [returntype, =>, 53]
semantic stack: 
[epsilon][function][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] [CREATE_NODE: returnType] <type> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer 
rule: 
<returnType>: <type> [CREATE_NODE: returnType] 
semantic stack: 
[epsilon][function][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] [CREATE_NODE: returnType] [CREATE_LEAF: integer] integer 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer 
rule: 
<type>: integer [CREATE_LEAF: integer] 
semantic stack: 
[epsilon][function][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] [CREATE_NODE: returnType] [CREATE_LEAF: integer] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer 
rule: 
matching: integer [integer, integer, 54]
semantic stack: 
[epsilon][function][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> opencubr [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
rule: 
<funcBody>: [EPSILON: epsilon] opencubr <multiLocalVarDeclOrStmt> closecubr [CREATE_NODE: functionBody] 
semantic stack: 
[epsilon][function][normalFunctionHead]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
rule: 
matching: opencubr [opencubr, {, 54]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar <expr> openpar return 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return 
rule: 
<statement>: return openpar <expr> closepar [CREATE_NODE: returnStatement] semi 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar <expr> openpar 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return 
rule: 
matching: return [return, return, 55]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 
rule: 
matching: openpar [openpar, (, 55]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 
rule: 
matching: intnum [intnum, 2, 55]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> <multOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * 
rule: 
<rightrecTerm>: <multOp> <factor> <rightrecTerm> 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [CREATE_LEAF: mult] mult 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * 
rule: 
<multOp>: mult [CREATE_LEAF: mult] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [CREATE_LEAF: mult] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * 
rule: 
matching: mult [mult, *, 55]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][numFactor][mult]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x 
rule: 
matching: id [id, x, 55]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][numFactor][mult][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][numFactor][mult][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][numFactor][mult][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][epsilon][epsilon][epsilon][numFactor][mult][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] closepar [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: returnStatement] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) 
rule: 
matching: closepar [closepar, ), 55]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
rule: 
matching: semi [semi, ;, 55]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][returnStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
rule: 
<multiLocalVarDeclOrStmt>: 
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][returnStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
rule: 
matching: closecubr [closecubr, }, 56]
semantic stack: 
[epsilon][function][normalFunctionHead][epsilon][returnStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <classDeclOrFuncDef> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class 
rule: 
<multiClassDeclOrFuncDef>: <classDeclOrFuncDef> <multiClassDeclOrFuncDef> 
semantic stack: 
[epsilon][function][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <classDecl> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class 
rule: 
<classDeclOrFuncDef>: <classDecl> 
semantic stack: 
[epsilon][function][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <optClassDecl2> [EPSILON: epsilon] [CREATE_LEAF: id] id [EPSILON: epsilon] class 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class 
rule: 
<classDecl>: class [EPSILON: epsilon] id [CREATE_LEAF: id] [EPSILON: epsilon] <optClassDecl2> [CREATE_NODE: extend] opencubr [EPSILON: epsilon] <multiVisiMemberDecl> [CREATE_NODE: classBody] closecubr [CREATE_NODE: class] semi 
semantic stack: 
[epsilon][function][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <optClassDecl2> [EPSILON: epsilon] [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class 
rule: 
matching: class [class, class, 58]
semantic stack: 
[epsilon][function][function]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] <optClassDecl2> [EPSILON: epsilon] [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C 
rule: 
matching: id [id, C, 58]
semantic stack: 
[epsilon][function][function][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] opencubr [CREATE_NODE: extend] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
rule: 
<optClassDecl2>: 
semantic stack: 
[epsilon][function][function][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
rule: 
matching: opencubr [opencubr, {, 58]
semantic stack: 
[epsilon][function][function][epsilon][id][extend]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> <visibility> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute 
rule: 
<multiVisiMemberDecl>: [EPSILON: epsilon] <visibility> <memberDecl> <multiVisiMemberDecl> 
semantic stack: 
[epsilon][function][function][epsilon][id][extend][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute 
rule: 
<visibility>: [CREATE_NODE: visibility] 
semantic stack: 
[epsilon][function][function][epsilon][id][extend][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberVarDecl> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute 
rule: 
<memberDecl>: <memberVarDecl> 
semantic stack: 
[epsilon][function][function][epsilon][id][extend][epsilon][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id attribute 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute 
rule: 
<memberVarDecl>: attribute id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: memberVarDecl] semi 
semantic stack: 
[epsilon][function][function][epsilon][id][extend][epsilon][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute 
rule: 
matching: attribute [attribute, attribute, 59]
semantic stack: 
[epsilon][function][function][epsilon][id][extend][epsilon][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a 
rule: 
matching: id [id, a, 59]
semantic stack: 
[epsilon][function][function][epsilon][id][extend][epsilon][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : 
rule: 
matching: colon [colon, :, 59]
semantic stack: 
[epsilon][function][function][epsilon][id][extend][epsilon][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: integer] integer 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer 
rule: 
<type>: integer [CREATE_LEAF: integer] 
semantic stack: 
[epsilon][function][function][epsilon][id][extend][epsilon][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: integer] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer 
rule: 
matching: integer [integer, integer, 59]
semantic stack: 
[epsilon][function][function][epsilon][id][extend][epsilon][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][function][function][epsilon][id][extend][epsilon][epsilon][visibility][id][integer][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
rule: 
matching: semi [semi, ;, 59]
semantic stack: 
[epsilon][function][function][epsilon][id][extend][epsilon][memberVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> <visibility> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute 
rule: 
<multiVisiMemberDecl>: [EPSILON: epsilon] <visibility> <memberDecl> <multiVisiMemberDecl> 
semantic stack: 
[epsilon][function][function][epsilon][id][extend][epsilon][memberVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute 
rule: 
<visibility>: [CREATE_NODE: visibility] 
semantic stack: 
[epsilon][function][function][epsilon][id][extend][epsilon][memberVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberVarDecl> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute 
rule: 
<memberDecl>: <memberVarDecl> 
semantic stack: 
[epsilon][function][function][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id attribute 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute 
rule: 
<memberVarDecl>: attribute id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: memberVarDecl] semi 
semantic stack: 
[epsilon][function][function][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute 
rule: 
matching: attribute [attribute, attribute, 60]
semantic stack: 
[epsilon][function][function][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b 
rule: 
matching: id [id, b, 60]
semantic stack: 
[epsilon][function][function][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : 
rule: 
matching: colon [colon, :, 60]
semantic stack: 
[epsilon][function][function][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: integer] integer 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer 
rule: 
<type>: integer [CREATE_LEAF: integer] 
semantic stack: 
[epsilon][function][function][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: integer] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer 
rule: 
matching: integer [integer, integer, 60]
semantic stack: 
[epsilon][function][function][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][function][function][epsilon][id][extend][epsilon][memberVarDecl][epsilon][visibility][id][integer][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
rule: 
matching: semi [semi, ;, 60]
semantic stack: 
[epsilon][function][function][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> <visibility> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute 
rule: 
<multiVisiMemberDecl>: [EPSILON: epsilon] <visibility> <memberDecl> <multiVisiMemberDecl> 
semantic stack: 
[epsilon][function][function][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberDecl> [CREATE_NODE: visibility] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute 
rule: 
<visibility>: [CREATE_NODE: visibility] 
semantic stack: 
[epsilon][function][function][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> <memberVarDecl> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute 
rule: 
<memberDecl>: <memberVarDecl> 
semantic stack: 
[epsilon][function][function][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id attribute 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute 
rule: 
<memberVarDecl>: attribute id [CREATE_LEAF: id] colon <type> [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] [CREATE_NODE: memberVarDecl] semi 
semantic stack: 
[epsilon][function][function][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] id 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute 
rule: 
matching: attribute [attribute, attribute, 61]
semantic stack: 
[epsilon][function][function][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> colon [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c 
rule: 
matching: id [id, c, 61]
semantic stack: 
[epsilon][function][function][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] <type> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : 
rule: 
matching: colon [colon, :, 61]
semantic stack: 
[epsilon][function][function][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: integer] integer 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer 
rule: 
<type>: integer [CREATE_LEAF: integer] 
semantic stack: 
[epsilon][function][function][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] [CREATE_LEAF: integer] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer 
rule: 
matching: integer [integer, integer, 61]
semantic stack: 
[epsilon][function][function][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> semi [CREATE_NODE: memberVarDecl] [CREATE_NODE: arraySizes] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][function][function][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][epsilon][visibility][id][integer][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] <multiVisiMemberDecl> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
rule: 
matching: semi [semi, ;, 61]
semantic stack: 
[epsilon][function][function][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] closecubr [CREATE_NODE: classBody] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} 
rule: 
<multiVisiMemberDecl>: 
semantic stack: 
[epsilon][function][function][epsilon][id][extend][epsilon][memberVarDecl][memberVarDecl][memberVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> semi [CREATE_NODE: class] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} 
rule: 
matching: closecubr [closecubr, }, 62]
semantic stack: 
[epsilon][function][function][epsilon][id][extend][classBody]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
rule: 
matching: semi [semi, ;, 62]
semantic stack: 
[epsilon][function][function][class]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <classDeclOrFuncDef> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function 
rule: 
<multiClassDeclOrFuncDef>: <classDeclOrFuncDef> <multiClassDeclOrFuncDef> 
semantic stack: 
[epsilon][function][function][class]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> <funcDef> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function 
rule: 
<classDeclOrFuncDef>: <funcDef> 
semantic stack: 
[epsilon][function][function][class]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHead> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function 
rule: 
<funcDef>: <funcHead> <funcBody> [CREATE_NODE: function] 
semantic stack: 
[epsilon][function][function][class]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] id function [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function 
rule: 
<funcHead>: [EPSILON: epsilon] function id [CREATE_LEAF: id] <funcHeadFollowing> 
semantic stack: 
[epsilon][function][function][class]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] id 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function 
rule: 
matching: function [function, function, 64]
semantic stack: 
[epsilon][function][function][class][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> <funcHeadFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main 
rule: 
matching: id [id, main, 64]
semantic stack: 
[epsilon][function][function][class][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] openpar 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( 
rule: 
<funcHeadFollowing>: openpar [EPSILON: epsilon] <fParams> [CREATE_NODE: fParams] closepar returntype <returnType> [CREATE_NODE: normalFunctionHead] 
semantic stack: 
[epsilon][function][function][class][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] <fParams> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( 
rule: 
matching: openpar [openpar, (, 64]
semantic stack: 
[epsilon][function][function][class][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype closepar [CREATE_NODE: fParams] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) 
rule: 
<fParams>: 
semantic stack: 
[epsilon][function][function][class][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> returntype 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) 
rule: 
matching: closepar [closepar, ), 64]
semantic stack: 
[epsilon][function][function][class][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] <returnType> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
rule: 
matching: returntype [returntype, =>, 64]
semantic stack: 
[epsilon][function][function][class][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] [CREATE_NODE: returnType] void 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void 
rule: 
<returnType>: void [CREATE_NODE: returnType] 
semantic stack: 
[epsilon][function][function][class][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] <funcBody> [CREATE_NODE: normalFunctionHead] [CREATE_NODE: returnType] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void 
rule: 
matching: void [void, void, 65]
semantic stack: 
[epsilon][function][function][class][epsilon][id][fParams]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> opencubr [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
rule: 
<funcBody>: [EPSILON: epsilon] opencubr <multiLocalVarDeclOrStmt> closecubr [CREATE_NODE: functionBody] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
rule: 
matching: opencubr [opencubr, {, 65]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDecl> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar 
rule: 
<localVarDeclOrStmt>: <localVarDecl> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id localvar [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar 
rule: 
<localVarDecl>: [EPSILON: epsilon] localvar id [CREATE_LEAF: id] colon <type> <localVarDeclFollowing> [CREATE_NODE: localVarDecl] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar 
rule: 
matching: localvar [localvar, localvar, 66]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x 
rule: 
matching: id [id, x, 66]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : 
rule: 
matching: colon [colon, :, 66]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: integer] integer 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer 
rule: 
<type>: integer [CREATE_LEAF: integer] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: integer] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer 
rule: 
matching: integer [integer, integer, 66]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; 
rule: 
<localVarDeclFollowing>: [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] semi 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][epsilon][id][integer]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][epsilon][id][integer][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; 
rule: 
matching: semi [semi, ;, 66]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][epsilon][id][integer][arraySizes]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
rule: 
skipping
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDecl> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar 
rule: 
<localVarDeclOrStmt>: <localVarDecl> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id localvar [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar 
rule: 
<localVarDecl>: [EPSILON: epsilon] localvar id [CREATE_LEAF: id] colon <type> <localVarDeclFollowing> [CREATE_NODE: localVarDecl] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar 
rule: 
matching: localvar [localvar, localvar, 67]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y 
rule: 
matching: id [id, y, 67]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : 
rule: 
matching: colon [colon, :, 67]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: integer] integer 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer 
rule: 
<type>: integer [CREATE_LEAF: integer] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: integer] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer 
rule: 
matching: integer [integer, integer, 67]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; 
rule: 
<localVarDeclFollowing>: [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] semi 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][epsilon][id][integer]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][epsilon][id][integer][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; 
rule: 
matching: semi [semi, ;, 67]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][epsilon][id][integer][arraySizes]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
rule: 
skipping
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDecl> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar 
rule: 
<localVarDeclOrStmt>: <localVarDecl> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id localvar [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar 
rule: 
<localVarDecl>: [EPSILON: epsilon] localvar id [CREATE_LEAF: id] colon <type> <localVarDeclFollowing> [CREATE_NODE: localVarDecl] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar 
rule: 
matching: localvar [localvar, localvar, 68]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z 
rule: 
matching: id [id, z, 68]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : 
rule: 
matching: colon [colon, :, 68]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: integer] integer 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer 
rule: 
<type>: integer [CREATE_LEAF: integer] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: integer] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer 
rule: 
matching: integer [integer, integer, 68]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; 
rule: 
<localVarDeclFollowing>: [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] semi 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][id][integer]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][id][integer][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; 
rule: 
matching: semi [semi, ;, 68]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][epsilon][id][integer][arraySizes]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
rule: 
skipping
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDecl> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar 
rule: 
<localVarDeclOrStmt>: <localVarDecl> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id localvar [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar 
rule: 
<localVarDecl>: [EPSILON: epsilon] localvar id [CREATE_LEAF: id] colon <type> <localVarDeclFollowing> [CREATE_NODE: localVarDecl] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar 
rule: 
matching: localvar [localvar, localvar, 69]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr 
rule: 
matching: id [id, arr, 69]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : 
rule: 
matching: colon [colon, :, 69]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: integer] integer 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer 
rule: 
<type>: integer [CREATE_LEAF: integer] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: integer] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer 
rule: 
matching: integer [integer, integer, 69]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 
rule: 
<localVarDeclFollowing>: [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] semi 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][id][integer]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] <multiArraySize> <arraySize> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 
rule: 
<multiArraySize>: <arraySize> <multiArraySize> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][id][integer][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] <multiArraySize> <arraySizeParam> [EPSILON: epsilon] opensqbr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 
rule: 
<arraySize>: opensqbr [EPSILON: epsilon] <arraySizeParam> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][id][integer][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] <multiArraySize> <arraySizeParam> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 
rule: 
matching: opensqbr [opensqbr, [, 69]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][id][integer][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] <multiArraySize> [CREATE_NODE: arraySize] closesqbr [CREATE_LEAF: intNum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 
rule: 
<arraySizeParam>: intnum [CREATE_LEAF: intNum] closesqbr [CREATE_NODE: arraySize] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][id][integer][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] <multiArraySize> [CREATE_NODE: arraySize] closesqbr [CREATE_LEAF: intNum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 
rule: 
matching: intnum [intnum, 7, 69]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][id][integer][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] <multiArraySize> [CREATE_NODE: arraySize] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] 
rule: 
matching: closesqbr [closesqbr, ], 69]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][id][integer][epsilon][epsilon][intNum]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][id][integer][epsilon][arraySize]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; 
rule: 
matching: semi [semi, ;, 69]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][epsilon][id][integer][arraySizes]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
rule: 
skipping
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDecl> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar 
rule: 
<localVarDeclOrStmt>: <localVarDecl> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id localvar [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar 
rule: 
<localVarDecl>: [EPSILON: epsilon] localvar id [CREATE_LEAF: id] colon <type> <localVarDeclFollowing> [CREATE_NODE: localVarDecl] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar 
rule: 
matching: localvar [localvar, localVar, 70]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m 
rule: 
matching: id [id, m, 70]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : 
rule: 
matching: colon [colon, :, 70]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: id] id 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C 
rule: 
<type>: id [CREATE_LEAF: id] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C 
rule: 
matching: id [id, C, 70]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; 
rule: 
<localVarDeclFollowing>: [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] semi 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][id][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][id][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; 
rule: 
matching: semi [semi, ;, 70]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][id][id][arraySizes]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
rule: 
skipping
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDecl> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar 
rule: 
<localVarDeclOrStmt>: <localVarDecl> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id localvar [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar 
rule: 
<localVarDecl>: [EPSILON: epsilon] localvar id [CREATE_LEAF: id] colon <type> <localVarDeclFollowing> [CREATE_NODE: localVarDecl] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] id 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar 
rule: 
matching: localvar [localvar, localVar, 71]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> colon [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n 
rule: 
matching: id [id, n, 71]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> <type> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : 
rule: 
matching: colon [colon, :, 71]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: id] id 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C 
rule: 
<type>: id [CREATE_LEAF: id] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] <localVarDeclFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C 
rule: 
matching: id [id, C, 71]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] <multiArraySize> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 
rule: 
<localVarDeclFollowing>: [EPSILON: epsilon] <multiArraySize> [CREATE_NODE: arraySizes] semi 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][id][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] <multiArraySize> <arraySize> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 
rule: 
<multiArraySize>: <arraySize> <multiArraySize> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][id][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] <multiArraySize> <arraySizeParam> [EPSILON: epsilon] opensqbr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 
rule: 
<arraySize>: opensqbr [EPSILON: epsilon] <arraySizeParam> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][id][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] <multiArraySize> <arraySizeParam> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 
rule: 
matching: opensqbr [opensqbr, [, 71]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][id][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] <multiArraySize> [CREATE_NODE: arraySize] closesqbr [CREATE_LEAF: intNum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 
rule: 
<arraySizeParam>: intnum [CREATE_LEAF: intNum] closesqbr [CREATE_NODE: arraySize] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][id][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] <multiArraySize> [CREATE_NODE: arraySize] closesqbr [CREATE_LEAF: intNum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 
rule: 
matching: intnum [intnum, 7, 71]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][id][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] <multiArraySize> [CREATE_NODE: arraySize] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] 
rule: 
matching: closesqbr [closesqbr, ], 71]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][id][id][epsilon][epsilon][intNum]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] semi [CREATE_NODE: arraySizes] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; 
rule: 
<multiArraySize>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][id][id][epsilon][arraySize]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> [CREATE_NODE: localVarDecl] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; 
rule: 
matching: semi [semi, ;, 71]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][id][id][arraySizes]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
rule: 
skipping
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr 
rule: 
matching: id [id, arr, 72]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 
rule: 
<optIdnestFollowing>: <idnestFollowing> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 
rule: 
<idnestFollowing>: [EPSILON: epsilon] <multiIndice> [CREATE_NODE: indices] [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> <indice> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 
rule: 
<multiIndice>: <indice> <multiIndice> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> opensqbr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 
rule: 
<indice>: opensqbr <arithExpr> closesqbr 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 
rule: 
matching: opensqbr [opensqbr, [, 72]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][epsilon][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 
rule: 
matching: intnum [intnum, 0, 72]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][epsilon][id][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][epsilon][id][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] 
rule: 
matching: closesqbr [closesqbr, ], 72]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 
rule: 
<multiIndice>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 
rule: 
matching: assign [assign, =, 72]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 
rule: 
matching: intnum [intnum, 64, 72]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][epsilon][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; 
rule: 
matching: semi [semi, ;, 72]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
rule: 
skipping
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr 
rule: 
matching: id [id, arr, 73]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 
rule: 
<optIdnestFollowing>: <idnestFollowing> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 
rule: 
<idnestFollowing>: [EPSILON: epsilon] <multiIndice> [CREATE_NODE: indices] [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> <indice> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 
rule: 
<multiIndice>: <indice> <multiIndice> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> opensqbr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 
rule: 
<indice>: opensqbr <arithExpr> closesqbr 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 
rule: 
matching: opensqbr [opensqbr, [, 73]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][epsilon][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 
rule: 
matching: intnum [intnum, 1, 73]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][epsilon][id][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] 
rule: 
matching: closesqbr [closesqbr, ], 73]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 
rule: 
<multiIndice>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 
rule: 
matching: assign [assign, =, 73]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 
rule: 
matching: intnum [intnum, 34, 73]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][epsilon][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; 
rule: 
matching: semi [semi, ;, 73]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
rule: 
skipping
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr 
rule: 
matching: id [id, arr, 74]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 
rule: 
<optIdnestFollowing>: <idnestFollowing> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 
rule: 
<idnestFollowing>: [EPSILON: epsilon] <multiIndice> [CREATE_NODE: indices] [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> <indice> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 
rule: 
<multiIndice>: <indice> <multiIndice> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> opensqbr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 
rule: 
<indice>: opensqbr <arithExpr> closesqbr 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 
rule: 
matching: opensqbr [opensqbr, [, 74]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 
rule: 
matching: intnum [intnum, 2, 74]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] 
rule: 
matching: closesqbr [closesqbr, ], 74]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 
rule: 
<multiIndice>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 
rule: 
matching: assign [assign, =, 74]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 
rule: 
matching: intnum [intnum, 25, 74]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][epsilon][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; 
rule: 
matching: semi [semi, ;, 74]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
rule: 
skipping
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr 
rule: 
matching: id [id, arr, 75]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 
rule: 
<optIdnestFollowing>: <idnestFollowing> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 
rule: 
<idnestFollowing>: [EPSILON: epsilon] <multiIndice> [CREATE_NODE: indices] [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> <indice> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 
rule: 
<multiIndice>: <indice> <multiIndice> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> opensqbr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 
rule: 
<indice>: opensqbr <arithExpr> closesqbr 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 
rule: 
matching: opensqbr [opensqbr, [, 75]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 
rule: 
matching: intnum [intnum, 3, 75]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] 
rule: 
matching: closesqbr [closesqbr, ], 75]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 
rule: 
<multiIndice>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 
rule: 
matching: assign [assign, =, 75]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 
rule: 
matching: intnum [intnum, 12, 75]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; 
rule: 
matching: semi [semi, ;, 75]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
rule: 
skipping
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr 
rule: 
matching: id [id, arr, 76]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 
rule: 
<optIdnestFollowing>: <idnestFollowing> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 
rule: 
<idnestFollowing>: [EPSILON: epsilon] <multiIndice> [CREATE_NODE: indices] [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> <indice> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 
rule: 
<multiIndice>: <indice> <multiIndice> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> opensqbr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 
rule: 
<indice>: opensqbr <arithExpr> closesqbr 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 
rule: 
matching: opensqbr [opensqbr, [, 76]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 
rule: 
matching: intnum [intnum, 4, 76]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] 
rule: 
matching: closesqbr [closesqbr, ], 76]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 
rule: 
<multiIndice>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 
rule: 
matching: assign [assign, =, 76]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 
rule: 
matching: intnum [intnum, 22, 76]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; 
rule: 
matching: semi [semi, ;, 76]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
rule: 
skipping
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr 
rule: 
matching: id [id, arr, 77]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 
rule: 
<optIdnestFollowing>: <idnestFollowing> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 
rule: 
<idnestFollowing>: [EPSILON: epsilon] <multiIndice> [CREATE_NODE: indices] [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> <indice> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 
rule: 
<multiIndice>: <indice> <multiIndice> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> opensqbr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 
rule: 
<indice>: opensqbr <arithExpr> closesqbr 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 
rule: 
matching: opensqbr [opensqbr, [, 77]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 
rule: 
matching: intnum [intnum, 5, 77]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] 
rule: 
matching: closesqbr [closesqbr, ], 77]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 
rule: 
<multiIndice>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 
rule: 
matching: assign [assign, =, 77]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 
rule: 
matching: intnum [intnum, 11, 77]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; 
rule: 
matching: semi [semi, ;, 77]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
rule: 
skipping
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr 
rule: 
matching: id [id, arr, 78]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <idnestFollowing> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 
rule: 
<optIdnestFollowing>: <idnestFollowing> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 
rule: 
<idnestFollowing>: [EPSILON: epsilon] <multiIndice> [CREATE_NODE: indices] [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> <indice> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 
rule: 
<multiIndice>: <indice> <multiIndice> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> opensqbr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 
rule: 
<indice>: opensqbr <arithExpr> closesqbr 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 
rule: 
matching: opensqbr [opensqbr, [, 78]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 
rule: 
matching: intnum [intnum, 6, 78]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] 
rule: 
matching: closesqbr [closesqbr, ], 78]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 
rule: 
<multiIndice>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 
rule: 
matching: assign [assign, =, 78]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 
rule: 
matching: intnum [intnum, 90, 78]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; 
rule: 
matching: semi [semi, ;, 78]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
rule: 
skipping
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y 
rule: 
matching: id [id, y, 79]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 
rule: 
matching: assign [assign, =, 79]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 
rule: 
matching: intnum [intnum, 1, 79]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> <addOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 
rule: 
<rightrecArithExpr>: <addOp> <term> <rightrecArithExpr> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] plus 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 
rule: 
<addOp>: plus [CREATE_LEAF: plus] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 
rule: 
matching: plus [plus, +, 79]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 
rule: 
matching: intnum [intnum, 2, 79]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> <multOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 
rule: 
<rightrecTerm>: <multOp> <factor> <rightrecTerm> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [CREATE_LEAF: mult] mult 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 
rule: 
<multOp>: mult [CREATE_LEAF: mult] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [CREATE_LEAF: mult] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 
rule: 
matching: mult [mult, *, 79]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon][numFactor][mult]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 
rule: 
matching: intnum [intnum, 3, 79]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon][numFactor][mult]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon][numFactor][mult][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][term][plus][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; 
rule: 
matching: semi [semi, ;, 79]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
rule: 
skipping
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar <expr> openpar write 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write 
rule: 
<statement>: write openpar <expr> closepar [CREATE_NODE: writeStatement] semi 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar <expr> openpar 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write 
rule: 
matching: write [write, write, 80]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( 
rule: 
matching: openpar [openpar, (, 80]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr 
rule: 
matching: id [id, arr, 80]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <idnestFollowing> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ 
rule: 
<optIdnestFollowing>: <idnestFollowing> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ 
rule: 
<idnestFollowing>: [EPSILON: epsilon] <multiIndice> [CREATE_NODE: indices] [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> <indice> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ 
rule: 
<multiIndice>: <indice> <multiIndice> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> opensqbr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ 
rule: 
<indice>: opensqbr <arithExpr> closesqbr 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ 
rule: 
matching: opensqbr [opensqbr, [, 80]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y 
rule: 
matching: id [id, y, 80]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> <addOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 
rule: 
<rightrecArithExpr>: <addOp> <term> <rightrecArithExpr> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: minus] minus 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 
rule: 
<addOp>: minus [CREATE_LEAF: minus] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: minus] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 
rule: 
matching: minus [minus, -, 80]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][term][minus]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][term][minus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 
rule: 
matching: intnum [intnum, 4, 80]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][term][minus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][term][minus][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][term][minus][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] 
rule: 
matching: closesqbr [closesqbr, ], 80]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) 
rule: 
<multiIndice>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) 
rule: 
matching: closepar [closepar, ), 80]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; 
rule: 
matching: semi [semi, ;, 80]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
rule: 
skipping
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi closepar [CREATE_NODE: readStatement] <variable> [EPSILON: epsilon] openpar read 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read 
rule: 
<statement>: read openpar [EPSILON: epsilon] <variable> [CREATE_NODE: readStatement] closepar semi 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi closepar [CREATE_NODE: readStatement] <variable> [EPSILON: epsilon] openpar 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read 
rule: 
matching: read [read, read, 81]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi closepar [CREATE_NODE: readStatement] <variable> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( 
rule: 
matching: openpar [openpar, (, 81]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi closepar [CREATE_NODE: readStatement] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x 
rule: 
<variable>: [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi closepar [CREATE_NODE: readStatement] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x 
rule: 
matching: id [id, x, 81]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi closepar [CREATE_NODE: readStatement] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi closepar [CREATE_NODE: readStatement] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) 
rule: 
matching: closepar [closepar, ), 81]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; 
rule: 
matching: semi [semi, ;, 81]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
rule: 
skipping
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z 
rule: 
matching: id [id, z, 82]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 
rule: 
matching: assign [assign, =, 82]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][epsilon][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 
rule: 
matching: intnum [intnum, 1, 82]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][epsilon][idIndice][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][epsilon][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
rule: 
matching: semi [semi, ;, 82]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z 
rule: 
matching: id [id, z, 83]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = 
rule: 
matching: assign [assign, =, 83]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add 
rule: 
matching: id [id, add, 83]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <idnestFollowing> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( 
rule: 
<optIdnestFollowing>: <idnestFollowing> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <aParams> openpar 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( 
rule: 
<idnestFollowing>: openpar <aParams> closepar [CREATE_NODE: funcCall] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <aParams> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( 
rule: 
matching: openpar [openpar, (, 83]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x 
rule: 
<aParams>: <expr> <multiAParamsTail> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x 
rule: 
matching: id [id, x, 83]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> <aParamsTail> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , 
rule: 
<multiAParamsTail>: <aParamsTail> <multiAParamsTail> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> <expr> comma 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , 
rule: 
<aParamsTail>: comma <expr> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , 
rule: 
matching: comma [comma, ,, 83]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][expr][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][expr][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][expr][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y 
rule: 
matching: id [id, y, 83]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][expr][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][expr][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][expr][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][expr][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][expr][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][expr][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> <aParamsTail> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , 
rule: 
<multiAParamsTail>: <aParamsTail> <multiAParamsTail> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][expr][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> <expr> comma 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , 
rule: 
<aParamsTail>: comma <expr> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][expr][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , 
rule: 
matching: comma [comma, ,, 83]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][expr][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][expr][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][expr][expr][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][expr][expr][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][expr][expr][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z 
rule: 
matching: id [id, z, 83]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][expr][expr][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][expr][expr][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][expr][expr][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][expr][expr][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][expr][expr][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar <multiAParamsTail> [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][expr][expr][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] closepar 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) 
rule: 
<multiAParamsTail>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][expr][expr][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: funcCall] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) 
rule: 
matching: closepar [closepar, ), 83]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id][expr][expr][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][funcCall]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][epsilon][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; 
rule: 
matching: semi [semi, ;, 83]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
rule: 
skipping
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar <expr> openpar write 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write 
rule: 
<statement>: write openpar <expr> closepar [CREATE_NODE: writeStatement] semi 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar <expr> openpar 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write 
rule: 
matching: write [write, write, 84]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( 
rule: 
matching: openpar [openpar, (, 84]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z 
rule: 
matching: id [id, z, 84]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: writeStatement] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) 
rule: 
matching: closepar [closepar, ), 84]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
rule: 
matching: semi [semi, ;, 84]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <relExpr> [EPSILON: epsilon] openpar if 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if 
rule: 
<statement>: if openpar [EPSILON: epsilon] <relExpr> [CREATE_NODE: ifCondition] closepar then [EPSILON: epsilon] <statBlock> [CREATE_NODE: thenStatements] else [EPSILON: epsilon] <statBlock> [CREATE_NODE: elseStatements] [CREATE_NODE: ifStatement] semi 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <relExpr> [EPSILON: epsilon] openpar 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if 
rule: 
matching: if [if, if, 85]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <relExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( 
rule: 
matching: openpar [openpar, (, 85]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> <arithExpr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x 
rule: 
<relExpr>: <arithExpr> <relOp> <arithExpr> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x 
rule: 
matching: id [id, x, 85]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> [CREATE_LEAF: gt] gt 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > 
rule: 
<relOp>: gt [CREATE_LEAF: gt] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] <arithExpr> [CREATE_LEAF: gt] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > 
rule: 
matching: gt [gt, >, 85]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][epsilon][arithExpr][gt]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][epsilon][arithExpr][gt][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][epsilon][arithExpr][gt][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y 
rule: 
matching: id [id, y, 85]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][epsilon][arithExpr][gt][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][epsilon][arithExpr][gt][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][epsilon][arithExpr][gt][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][epsilon][arithExpr][gt][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> <addOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 
rule: 
<rightrecArithExpr>: <addOp> <term> <rightrecArithExpr> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][epsilon][arithExpr][gt][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] plus 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 
rule: 
<addOp>: plus [CREATE_LEAF: plus] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][epsilon][arithExpr][gt][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 
rule: 
matching: plus [plus, +, 85]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][epsilon][arithExpr][gt][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][epsilon][arithExpr][gt][epsilon][term][plus]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][epsilon][arithExpr][gt][epsilon][term][plus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 
rule: 
matching: intnum [intnum, 10, 85]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][epsilon][arithExpr][gt][epsilon][term][plus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][epsilon][arithExpr][gt][epsilon][term][plus][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then closepar [CREATE_NODE: ifCondition] [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][epsilon][arithExpr][gt][epsilon][term][plus][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] then 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) 
rule: 
matching: closepar [closepar, ), 85]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] <statBlock> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then 
rule: 
matching: then [then, then, 85]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> opencubr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { 
rule: 
<statBlock>: opencubr <multiStatement> closecubr 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { 
rule: 
matching: opencubr [opencubr, {, 85]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
rule: 
skipping
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write 
rule: 
<multiStatement>: <statement> <multiStatement> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar <expr> openpar write 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write 
rule: 
<statement>: write openpar <expr> closepar [CREATE_NODE: writeStatement] semi 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar <expr> openpar 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write 
rule: 
matching: write [write, write, 86]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( 
rule: 
matching: openpar [openpar, (, 86]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x 
rule: 
matching: id [id, x, 86]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][epsilon][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][epsilon][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> <addOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 
rule: 
<rightrecArithExpr>: <addOp> <term> <rightrecArithExpr> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][epsilon][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] plus 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 
rule: 
<addOp>: plus [CREATE_LEAF: plus] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][epsilon][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 
rule: 
matching: plus [plus, +, 86]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][epsilon][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][epsilon][epsilon][epsilon][term][plus]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][epsilon][epsilon][epsilon][term][plus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 
rule: 
matching: intnum [intnum, 10, 86]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][epsilon][epsilon][epsilon][term][plus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][epsilon][epsilon][epsilon][term][plus][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][epsilon][epsilon][epsilon][term][plus][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][epsilon][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) 
rule: 
matching: closepar [closepar, ), 86]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][epsilon][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; 
rule: 
matching: semi [semi, ;, 86]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][epsilon][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
rule: 
skipping
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][epsilon][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] closecubr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} 
rule: 
<multiStatement>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][epsilon][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] else [CREATE_NODE: thenStatements] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} 
rule: 
matching: closecubr [closecubr, }, 87]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][epsilon][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] <statBlock> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else 
rule: 
matching: else [else, else, 87]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][thenStatements]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> opencubr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
rule: 
<statBlock>: opencubr <multiStatement> closecubr 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][thenStatements][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
rule: 
matching: opencubr [opencubr, {, 87]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][thenStatements][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write 
rule: 
<multiStatement>: <statement> <multiStatement> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][thenStatements][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar <expr> openpar write 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write 
rule: 
<statement>: write openpar <expr> closepar [CREATE_NODE: writeStatement] semi 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][thenStatements][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar <expr> openpar 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write 
rule: 
matching: write [write, write, 88]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][thenStatements][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( 
rule: 
matching: openpar [openpar, (, 88]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][thenStatements][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][thenStatements][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][thenStatements][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][thenStatements][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][thenStatements][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x 
rule: 
matching: id [id, x, 88]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][thenStatements][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][thenStatements][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][thenStatements][epsilon][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][thenStatements][epsilon][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> <addOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 
rule: 
<rightrecArithExpr>: <addOp> <term> <rightrecArithExpr> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][thenStatements][epsilon][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] plus 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 
rule: 
<addOp>: plus [CREATE_LEAF: plus] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][thenStatements][epsilon][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 
rule: 
matching: plus [plus, +, 88]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][thenStatements][epsilon][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][thenStatements][epsilon][epsilon][epsilon][term][plus]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][thenStatements][epsilon][epsilon][epsilon][term][plus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 
rule: 
matching: intnum [intnum, 1, 88]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][thenStatements][epsilon][epsilon][epsilon][term][plus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][thenStatements][epsilon][epsilon][epsilon][term][plus][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][thenStatements][epsilon][epsilon][epsilon][term][plus][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][thenStatements][epsilon][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) 
rule: 
matching: closepar [closepar, ), 88]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][thenStatements][epsilon][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; 
rule: 
matching: semi [semi, ;, 88]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][thenStatements][epsilon][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
rule: 
skipping
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][thenStatements][epsilon][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] closecubr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} 
rule: 
<multiStatement>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][thenStatements][epsilon][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: ifStatement] [CREATE_NODE: elseStatements] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} 
rule: 
matching: closecubr [closecubr, }, 89]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifCondition][thenStatements][epsilon][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
rule: 
matching: semi [semi, ;, 89]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z 
rule: 
matching: id [id, z, 90]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi <functionCallOrAssignStat> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 
rule: 
matching: assign [assign, =, 90]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][epsilon][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 
rule: 
matching: intnum [intnum, 0, 90]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][epsilon][idIndice][epsilon][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][epsilon][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; 
rule: 
matching: semi [semi, ;, 90]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
rule: 
skipping
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
rule: 
skipping
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <localVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while 
rule: 
<multiLocalVarDeclOrStmt>: <localVarDeclOrStmt> <multiLocalVarDeclOrStmt> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while 
rule: 
<localVarDeclOrStmt>: <statement> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <relExpr> [EPSILON: epsilon] openpar while 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while 
rule: 
<statement>: while openpar [EPSILON: epsilon] <relExpr> [CREATE_NODE: whileCondition] closepar [EPSILON: epsilon] <statBlock> [CREATE_NODE: whileBlockStatements] [CREATE_NODE: whileStatement] semi 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <relExpr> [EPSILON: epsilon] openpar 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while 
rule: 
matching: while [while, while, 92]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <relExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( 
rule: 
matching: openpar [openpar, (, 92]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> <arithExpr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z 
rule: 
<relExpr>: <arithExpr> <relOp> <arithExpr> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z 
rule: 
matching: id [id, z, 92]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> <relOp> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> [CREATE_LEAF: leq] leq 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 
rule: 
<relOp>: leq [CREATE_LEAF: leq] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] <arithExpr> [CREATE_LEAF: leq] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 
rule: 
matching: leq [leq, <=, 92]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][epsilon][arithExpr][leq]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][epsilon][arithExpr][leq][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][epsilon][arithExpr][leq][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 
rule: 
matching: intnum [intnum, 6, 92]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][epsilon][arithExpr][leq][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][epsilon][arithExpr][leq][epsilon][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] closepar [CREATE_NODE: whileCondition] [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][epsilon][arithExpr][leq][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] <statBlock> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) 
rule: 
matching: closepar [closepar, ), 92]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> opencubr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { 
rule: 
<statBlock>: opencubr <multiStatement> closecubr 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { 
rule: 
matching: opencubr [opencubr, {, 92]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
rule: 
skipping
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write 
rule: 
<multiStatement>: <statement> <multiStatement> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar <expr> openpar write 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write 
rule: 
<statement>: write openpar <expr> closepar [CREATE_NODE: writeStatement] semi 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar <expr> openpar 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write 
rule: 
matching: write [write, write, 93]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( 
rule: 
matching: openpar [openpar, (, 93]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr 
rule: 
matching: id [id, arr, 93]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <idnestFollowing> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ 
rule: 
<optIdnestFollowing>: <idnestFollowing> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ 
rule: 
<idnestFollowing>: [EPSILON: epsilon] <multiIndice> [CREATE_NODE: indices] [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> <indice> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ 
rule: 
<multiIndice>: <indice> <multiIndice> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> opensqbr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ 
rule: 
<indice>: opensqbr <arithExpr> closesqbr 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr <arithExpr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ 
rule: 
matching: opensqbr [opensqbr, [, 93]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z 
rule: 
matching: id [id, z, 93]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z ] 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z ] 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z ] 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> closesqbr [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z ] 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] <multiIndice> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z ] 
rule: 
matching: closesqbr [closesqbr, ], 93]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] [CREATE_NODE: indices] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z ] ) 
rule: 
<multiIndice>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][epsilon][id][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z ] ) 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z ] ) 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z ] ) 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] closepar [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z ] ) 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: writeStatement] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z ] ) 
rule: 
matching: closepar [closepar, ), 93]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][expr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z ] ) ; 
rule: 
matching: semi [semi, ;, 93]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z ] ) ; // 3.4, 4.1 
rule: 
skipping
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> <statement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z ] ) ; // 3.4, 4.1 
z 
rule: 
<multiStatement>: <statement> <multiStatement> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z ] ) ; // 3.4, 4.1 
z 
rule: 
<statement>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> <functionCallOrAssignStat> semi 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z ] ) ; // 3.4, 4.1 
z 
rule: 
matching: id [id, z, 94]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z ] ) ; // 3.4, 4.1 
z = 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi <functionCallOrAssignStat> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z ] ) ; // 3.4, 4.1 
z = 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] <expr> <assignOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z ] ) ; // 3.4, 4.1 
z = 
rule: 
<functionCallOrAssignStat>: <assignOp> <expr> [CREATE_NODE: assignStatement] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] <expr> assign 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z ] ) ; // 3.4, 4.1 
z = 
rule: 
<assignOp>: assign 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] <expr> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z ] ) ; // 3.4, 4.1 
z = 
rule: 
matching: assign [assign, =, 94]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> <arithExpr> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z ] ) ; // 3.4, 4.1 
z = z 
rule: 
<expr>: [EPSILON: epsilon] <arithExpr> <exprFollowing> [CREATE_NODE: expr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z ] ) ; // 3.4, 4.1 
z = z 
rule: 
<arithExpr>: [EPSILON: epsilon] <term> <rightrecArithExpr> [CREATE_NODE: arithExpr] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z ] ) ; // 3.4, 4.1 
z = z 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] id [EPSILON: epsilon] [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z ] ) ; // 3.4, 4.1 
z = z 
rule: 
<factor>: [EPSILON: epsilon] [EPSILON: epsilon] id [CREATE_LEAF: id] <optIdnestFollowing> <multiIdnest> [CREATE_NODE: idFactor] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> <optIdnestFollowing> [CREATE_LEAF: id] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z ] ) ; // 3.4, 4.1 
z = z 
rule: 
matching: id [id, z, 94]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] <multiIdnest> [CREATE_NODE: idIndice] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z ] ) ; // 3.4, 4.1 
z = z + 
rule: 
<optIdnestFollowing>: [CREATE_NODE: idIndice] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][epsilon][id]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: idFactor] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z ] ) ; // 3.4, 4.1 
z = z + 
rule: 
<multiIdnest>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice][epsilon][epsilon][epsilon][epsilon][idIndice]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z ] ) ; // 3.4, 4.1 
z = z + 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice][epsilon][epsilon][epsilon][idFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> <addOp> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z ] ) ; // 3.4, 4.1 
z = z + 
rule: 
<rightrecArithExpr>: <addOp> <term> <rightrecArithExpr> 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] plus 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z ] ) ; // 3.4, 4.1 
z = z + 
rule: 
<addOp>: plus [CREATE_LEAF: plus] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> <term> [CREATE_LEAF: plus] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z ] ) ; // 3.4, 4.1 
z = z + 
rule: 
matching: plus [plus, +, 94]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice][epsilon][epsilon][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> <factor> [EPSILON: epsilon] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z ] ) ; // 3.4, 4.1 
z = z + 1 
rule: 
<term>: [EPSILON: epsilon] <factor> <rightrecTerm> [CREATE_NODE: term] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice][epsilon][epsilon][term][plus]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] intnum 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z ] ) ; // 3.4, 4.1 
z = z + 1 
rule: 
<factor>: intnum [CREATE_LEAF: intnum] [CREATE_NODE: numFactor] 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] <rightrecTerm> [CREATE_NODE: numFactor] [CREATE_LEAF: intnum] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z ] ) ; // 3.4, 4.1 
z = z + 1 
rule: 
matching: intnum [intnum, 1, 94]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] <rightrecArithExpr> [CREATE_NODE: term] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z ] ) ; // 3.4, 4.1 
z = z + 1 ; 
rule: 
<rightrecTerm>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice][epsilon][epsilon][term][plus][epsilon][numFactor]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] <exprFollowing> [CREATE_NODE: arithExpr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z ] ) ; // 3.4, 4.1 
z = z + 1 ; 
rule: 
<rightrecArithExpr>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice][epsilon][epsilon][term][plus][term]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> semi [CREATE_NODE: assignStatement] [CREATE_NODE: expr] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z ] ) ; // 3.4, 4.1 
z = z + 1 ; 
rule: 
<exprFollowing>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][epsilon][idIndice][epsilon][arithExpr]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z ] ) ; // 3.4, 4.1 
z = z + 1 ; 
rule: 
matching: semi [semi, ;, 94]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr <multiStatement> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z ] ) ; // 3.4, 4.1 
z = z + 1 ; // 3.1 
rule: 
skipping
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] closecubr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z ] ) ; // 3.4, 4.1 
z = z + 1 ; // 3.1 
} 
rule: 
<multiStatement>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> semi [CREATE_NODE: whileStatement] [CREATE_NODE: whileBlockStatements] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z ] ) ; // 3.4, 4.1 
z = z + 1 ; // 3.1 
} 
rule: 
matching: closecubr [closecubr, }, 95]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileCondition][epsilon][writeStatement][assignStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr <multiLocalVarDeclOrStmt> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z ] ) ; // 3.4, 4.1 
z = z + 1 ; // 3.1 
} ; 
rule: 
matching: semi [semi, ;, 95]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] closecubr 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z ] ) ; // 3.4, 4.1 
z = z + 1 ; // 3.1 
} ; 
} 
rule: 
<multiLocalVarDeclOrStmt>: 
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileStatement]
-----------------------------------------------------------------------
stack: 
<$> [CREATE_NODE: program] <multiClassDeclOrFuncDef> [CREATE_NODE: function] [CREATE_NODE: functionBody] 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z ] ) ; // 3.4, 4.1 
z = z + 1 ; // 3.1 
} ; 
} 
rule: 
matching: closecubr [closecubr, }, 96]
semantic stack: 
[epsilon][function][function][class][normalFunctionHead][epsilon][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][localVarDecl][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][assignStatement][writeStatement][readStatement][assignStatement][assignStatement][writeStatement][ifStatement][assignStatement][whileStatement]
-----------------------------------------------------------------------
stack: 
<$> 
input: 
/*
1.1  Allocate memory for basic types (integer, float).
1.2  Allocate memory for arrays of basic types.
1.3  Allocate memory for objects.
1.4  Allocate memory for arrays of objects.
2.1  Branch to a functionâs code block, execute the code block, branch back to the calling function.
2.2  Pass parameters as local values to the functionâs code block.
2.3  Upon execution of a return statement, pass the return value back to the calling function.
2.4  Call to member functions that can use their objectâs data members.
3.1 Assignment statement: assignment of the resulting value of an expression to a variable, independently of what is the expression to the right of the assignment operator.
3.2 Conditional statement: implementation of a branching mechanism.
3.3 Loop statement: implementation of a branching mechanism.
3.4 Input/output statement: Moon machine keyboard input/console output
4.1. For arrays of basic types (integer and float), access to an arrayâs elements.
4.2. For arrays of objects, access to an arrayâs elementâs data members.
4.3. For objects, access to members of basic types.
4.4. For objects, access to members of array or object types.
5.1. Computing the value of an entire complex expression.
5.2. Expression involving an array factor whose indexes are themselves expressions.
5.3. Expression involving an object factor referring to object members.
*/ 
// Assignment 5 coverage: 
//      ------------- 
//      | YES | NO  | 
//      -------------  
// 1.1: |  X  |     | 
// 1.2: |  X  |     | 
// 1.3: |  X  |     | 
// 1.4: |  X  |     | 
// 2.1: |  X  |     | 
// 2.2: |  X  |     | 
// 2.3: |  X  |     | 
// 2.4: |     |  X  | 
// 3.1: |  X  |     | 
// 3.2: |  X  |     | 
// 3.3: |  X  |     | 
// 3.4: |  X  |     | 
// 4.1: |  X  |     | 
// 4.2: |     |  X  |  
// 4.3: |     |  X  | 
// 4.4: |     |  X  | 
// 5.1: |  X  |     | 
// 5.2: |  X  |     | 
// 5.3: |     |  X  | 
//      ------------- 
function add ( x : integer , y : integer , z : integer ) => 
integer { 
return ( multi2 ( x ) + y + z ) ; 
} 
function multi2 ( x : integer ) => 
integer { 
return ( 2 * x ) ; 
} 
class C { 
attribute a : integer ; 
attribute b : integer ; 
attribute c : integer ; 
} ; 
function main ( ) => 
void { 
localvar x : integer ; // 1.1 
localvar y : integer ; // 1.1 
localvar z : integer ; // 1.1 
localvar arr : integer [ 7 ] ; // 1.2 
localVar m : C ; // 1.3 
localVar n : C [ 7 ] ; // 1.4 
arr [ 0 ] = 64 ; // 3.1 
arr [ 1 ] = 34 ; // 3.1 
arr [ 2 ] = 25 ; // 3.1 
arr [ 3 ] = 12 ; // 3.1 
arr [ 4 ] = 22 ; // 3.1 
arr [ 5 ] = 11 ; // 3.1 
arr [ 6 ] = 90 ; // 3.1 
y = 1 + 2 * 3 ; // 3.1, 5.1 
write ( arr [ y - 4 ] ) ; // 4.1, 5.2 
read ( x ) ; // 3.4 
z = 1 ; 
z = add ( x , y , z ) ; // 2.1, 2.2, 2,3 
write ( z ) ; 
if ( x > y + 10 ) then { // 3.2, 5.1 
write ( x + 10 ) ; // 3.4, 5.1 
} else { 
write ( x + 1 ) ; // 3.4, 5.1 
} ; 
z = 0 ; // 3.1 
// write(arr[z + 1]); 
while ( z <= 6 ) { // 3.3, 5.1 
write ( arr [ z ] ) ; // 3.4, 4.1 
z = z + 1 ; // 3.1 
} ; 
} 
rule: 
<multiClassDeclOrFuncDef>: 
semantic stack: 
[program]
-----------------------------------------------------------------------
